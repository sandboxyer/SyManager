/**
 * Auto-generated wrapper for C file: newtest.c
 * Original path: newtest.c
 * Generated on: 2026-02-27T21:11:48.052Z
 * File size: 147279 characters (escaped)
 */
const newtest = `#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <time.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/mman.h>\n#include <semaphore.h>\n\n#define RED     "\\033[1;31m"\n#define GREEN   "\\033[1;32m"\n#define YELLOW  "\\033[1;33m"\n#define BLUE    "\\033[1;34m"\n#define MAGENTA "\\033[1;35m"\n#define CYAN    "\\033[1;36m"\n#define RESET   "\\033[0m"\n#define BOLD    "\\033[1m"\n\n// ==================== TEST MODES ====================\n#define TEST_MODE_NORMAL 0\n#define TEST_MODE_CLI    1\n#define TEST_MODE_SERVER 2\n\n// ==================== TEST CATEGORIES ====================\n#define CATEGORY_SMOKE       0\n#define CATEGORY_DURABILITY  1\n#define CATEGORY_CONCURRENCY 2\n#define CATEGORY_QUERY       3\n#define CATEGORY_SCHEMA      4\n#define CATEGORY_SECURITY    5\n#define CATEGORY_PERFORMANCE 6\n#define CATEGORY_INTEGRITY   7\n#define CATEGORY_EDGE        8\n#define CATEGORY_RECOVERY    9\n\n// ==================== FUNCTION PROTOTYPES FOR HTTP TESTS ====================\nint run_http_database_tests(void);\nint run_http_collection_tests(void);\nint run_http_instance_tests(void);\nint run_http_command_tests(void);\nint run_http_error_tests(void);\nvoid cleanup_test_databases(void);\nint run_data_integrity_tests_cli(void);\n\n// New enhanced test functions for level 3\nint run_http_stress_tests(void);\nint run_http_data_corruption_tests(void);\nint run_http_mixed_workload_tests(void);\nint run_http_long_running_tests(void);\nint run_http_consistency_tests(void);\nint run_http_fault_injection_tests(void);\nint run_http_chaos_tests(void);\nint run_http_boundary_tests_extreme(void);\n\nconst char* category_names[] = {\n    "SMOKE TESTS",\n    "DURABILITY & CRASH RECOVERY",\n    "CONCURRENCY & THREAD SAFETY",\n    "QUERY LANGUAGE & INDEXING",\n    "SCHEMA ENFORCEMENT",\n    "SECURITY & INJECTION",\n    "PERFORMANCE & SCALABILITY",\n    "DATA INTEGRITY",\n    "EDGE CASES",\n    "RECOVERY & ERROR HANDLING"\n};\n\n// ==================== TEST STRUCTURES ====================\n\ntypedef struct {\n    char description[512];\n    char command[1024];\n    char verification_command[1024];\n    char expected_output[1024];\n    int success;\n    int verification_success;\n    long long duration_ms;\n    char details[1024];\n    char verbose_output[4096];\n    int category;\n    int critical;  // If critical fails, overall test fails\n} TestCase;\n\ntypedef struct {\n    char description[512];\n    int (*test_function)(void);\n    int category;\n    int critical;\n    long long duration_ms;\n    int passed;\n    char error_message[1024];\n} AdvancedTestCase;\n\n// ==================== GLOBAL CONFIGURATION ====================\n\nchar cli_command[32] = "./sydb";\nint test_mode = TEST_MODE_NORMAL;\nchar server_url[256] = "http://localhost:8080";\nint verbose_mode = 0;\nint test_level = 2;  // 0=quick, 1=standard, 2=comprehensive, 3=extreme\npid_t server_pid = 0;\nint server_started_by_test = 0;\n\n// ==================== TEST STATISTICS ====================\n\ntypedef struct {\n    int total_tests;\n    int passed_tests;\n    int failed_tests;\n    int skipped_tests;\n    long long total_duration;\n    int critical_failures;\n    int categories_passed[10];\n    int categories_total[10];\n} TestStatistics;\n\nTestStatistics stats = {0};\n\n// ==================== HTTP CLIENT (Enhanced) ====================\n\ntypedef struct {\n    int status_code;\n    char* body;\n    size_t body_length;\n    char* headers[50];\n    int header_count;\n} HttpResponse;\n\n// ==================== CONCURRENCY TEST STRUCTURES ====================\n\ntypedef struct {\n    char database[64];\n    char collection[64];\n    int thread_id;\n    int operations_count;\n    int success_count;\n    long long total_time;\n} ThreadTestContext;\n\ntypedef struct {\n    int active_connections;\n    int total_requests;\n    int success_requests;\n    pthread_mutex_t lock;\n} ConcurrencyStats;\n\n// ==================== FUNCTION PROTOTYPES ====================\n\nint run_data_integrity_tests_cli(void) {\n    return run_integrity_tests_cli();\n}\n\n// Core test functions\nlong long get_current_time_ms();\nint file_exists(const char *path);\nint count_files_in_directory(const char *path);\nint count_instances_in_collection(const char *database, const char *collection);\nchar* get_last_inserted_id(const char *database, const char *collection);\nint execute_command_and_capture(const char *command, char *output, size_t output_size);\nint execute_command_and_capture_verbose(const char *command, char *output, size_t output_size, char *verbose_output, size_t verbose_size);\nint execute_test_with_verification(TestCase *test);\nint execute_advanced_test(AdvancedTestCase *test);\n\n// HTTP client functions\nHttpResponse* http_request(const char* method, const char* url, const char* body, const char* content_type);\nvoid http_response_free(HttpResponse* response);\nint verify_http_response(const HttpResponse* response, const char* expected_pattern, int check_success_only);\nchar* extract_json_field(const char* json, const char* field);\nint http_test_endpoint(const char* description, const char* method, const char* endpoint, \n                      const char* body, const char* expected_pattern, int check_success_only, \n                      long long* duration, int category, int critical);\n\n// Server management\nint start_sydb_server();\nint stop_sydb_server();\nint wait_for_server_ready(int timeout_seconds);\n\n// ==================== ENHANCED TEST SUITES ====================\n\n// Smoke Tests (Basic functionality - your existing tests)\nint run_smoke_tests_cli();\nint run_smoke_tests_http();\n\n// ==================== CRITICAL NEW TEST SUITES ====================\n\n// DURABILITY TESTS - What happens on crash/power failure\nint run_durability_tests_cli();\nint run_durability_tests_http();\n\n// CONCURRENCY TESTS - Multi-threaded access\nint run_concurrency_tests_cli();\nint run_concurrency_tests_http();\n\n// QUERY LANGUAGE TESTS - Beyond simple equality\nint run_query_language_tests_cli();\nint run_query_language_tests_http();\n\n// SCHEMA ENFORCEMENT TESTS - Actual validation\nint run_schema_enforcement_tests_cli();\nint run_schema_enforcement_tests_http();\n\n// SECURITY TESTS - Injection, traversal, auth\nint run_security_tests_cli();\nint run_security_tests_http();\n\n// PERFORMANCE TESTS - Large datasets, indexing\nint run_performance_tests_cli();\nint run_performance_tests_http();\n\n// DATA INTEGRITY TESTS - Corruption detection\nint run_integrity_tests_cli();\nint run_integrity_tests_http();\n\n// RECOVERY TESTS - Restart after failure\nint run_recovery_tests_cli();\nint run_recovery_tests_http();\n\n// EDGE CASE TESTS - Extreme inputs\nint run_edge_case_tests_cli();\nint run_edge_case_tests_http();\n\n// ==================== UTILITY FUNCTIONS (Enhanced) ====================\n\nlong long get_current_time_ms() {\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (long long)tv.tv_sec * 1000 + tv.tv_usec / 1000;\n}\n\nvoid msleep(int ms) {\n    usleep(ms * 1000);\n}\n\nint file_exists(const char *path) {\n    struct stat st;\n    return stat(path, &st) == 0;\n}\n\nint count_files_in_directory(const char *path) {\n    DIR *dir = opendir(path);\n    if (!dir) return -1;\n    \n    int count = 0;\n    struct dirent *entry;\n    while ((entry = readdir(dir)) != NULL) {\n        if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {\n            count++;\n        }\n    }\n    closedir(dir);\n    return count;\n}\n\nint get_file_size(const char *path) {\n    struct stat st;\n    if (stat(path, &st) == 0) {\n        return st.st_size;\n    }\n    return -1;\n}\n\nint calculate_file_checksum(const char *path) {\n    FILE *fp = fopen(path, "rb");\n    if (!fp) return 0;\n    \n    int checksum = 0;\n    int c;\n    while ((c = fgetc(fp)) != EOF) {\n        checksum = (checksum + c) & 0xFFFF;\n    }\n    fclose(fp);\n    return checksum;\n}\n\nint count_instances_in_collection(const char *database, const char *collection) {\n    char command[512];\n    snprintf(command, sizeof(command), "%s list %s %s 2>/dev/null | grep -c '\\"_id\\"'", \n             cli_command, database, collection);\n    \n    FILE *fp = popen(command, "r");\n    if (!fp) return -1;\n    \n    int count = 0;\n    char buffer[64];\n    if (fgets(buffer, sizeof(buffer), fp)) {\n        count = atoi(buffer);\n    }\n    pclose(fp);\n    \n    return count;\n}\n\nchar* get_last_inserted_id(const char *database, const char *collection) {\n    char command[512];\n    snprintf(command, sizeof(command), "%s list %s %s 2>/dev/null | tail -1", \n             cli_command, database, collection);\n    \n    FILE *fp = popen(command, "r");\n    if (!fp) return NULL;\n    \n    static char id[64];\n    if (fgets(id, sizeof(id), fp)) {\n        char *id_start = strstr(id, "\\"_id\\":\\"");\n        if (id_start) {\n            id_start += 7;\n            char *id_end = strchr(id_start, '"');\n            if (id_end) {\n                *id_end = '\\0';\n                strncpy(id, id_start, sizeof(id) - 1);\n                pclose(fp);\n                return id;\n            }\n        }\n    }\n    pclose(fp);\n    return NULL;\n}\n\nint execute_command_and_capture(const char *command, char *output, size_t output_size) {\n    FILE *fp = popen(command, "r");\n    if (!fp) return -1;\n    \n    output[0] = '\\0';\n    if (fgets(output, output_size, fp)) {\n        output[strcspn(output, "\\n")] = '\\0';\n    }\n    pclose(fp);\n    return 0;\n}\n\nint execute_command_and_capture_verbose(const char *command, char *output, size_t output_size, \n                                       char *verbose_output, size_t verbose_size) {\n    if (verbose_mode) {\n        printf(YELLOW "  [VERBOSE] Executing: %s\\n" RESET, command);\n    }\n    \n    FILE *fp = popen(command, "r");\n    if (!fp) {\n        if (verbose_mode) printf(RED "  [VERBOSE] popen failed\\n" RESET);\n        return -1;\n    }\n    \n    output[0] = '\\0';\n    verbose_output[0] = '\\0';\n    \n    char buffer[1024];\n    size_t total_verbose_size = 0;\n    \n    while (fgets(buffer, sizeof(buffer), fp)) {\n        buffer[strcspn(buffer, "\\n")] = '\\0';\n        \n        if (output[0] == '\\0') {\n            strncpy(output, buffer, output_size - 1);\n            output[output_size - 1] = '\\0';\n        }\n        \n        if (total_verbose_size + strlen(buffer) < verbose_size - 1) {\n            strcat(verbose_output, buffer);\n            strcat(verbose_output, "\\n");\n            total_verbose_size += strlen(buffer) + 1;\n        }\n    }\n    \n    int status = pclose(fp);\n    int result;\n    \n    if (WIFEXITED(status)) {\n        int exit_code = WEXITSTATUS(status);\n        if (strstr(command, "grep") != NULL) {\n            result = (exit_code == 0 || exit_code == 1) ? 0 : -1;\n        } else {\n            result = (exit_code == 0) ? 0 : -1;\n        }\n    } else {\n        result = -1;\n    }\n    \n    if (verbose_mode) {\n        printf(YELLOW "  [VERBOSE] Exit: %d, Output: %s\\n" RESET, result, output);\n    }\n    \n    return result;\n}\n\nint execute_test_with_verification(TestCase *test) {\n    stats.total_tests++;\n    \n    printf("\\n%s%-80s" RESET, BLUE, test->description);\n    fflush(stdout);\n    \n    long long start_time = get_current_time_ms();\n    \n    int result = system(test->command);\n    long long end_time = get_current_time_ms();\n    \n    test->duration_ms = end_time - start_time;\n    test->success = (result == 0);\n    stats.total_duration += test->duration_ms;\n    \n    if (verbose_mode && !test->success) {\n        printf(YELLOW "\\n  [VERBOSE] Command failed: %s\\n" RESET, test->command);\n        printf(YELLOW "  [VERBOSE] Exit code: %d\\n" RESET, result);\n    }\n    \n    test->verification_success = 1;\n    if (test->success && test->verification_command[0] != '\\0') {\n        char verification_output[1024];\n        char verbose_output[4096];\n        int verification_result;\n        \n        if (verbose_mode) {\n            verification_result = execute_command_and_capture_verbose(test->verification_command, \n                                                                   verification_output, \n                                                                   sizeof(verification_output),\n                                                                   verbose_output,\n                                                                   sizeof(verbose_output));\n            strncpy(test->verbose_output, verbose_output, sizeof(test->verbose_output) - 1);\n        } else {\n            verification_result = execute_command_and_capture(test->verification_command, \n                                                            verification_output, \n                                                            sizeof(verification_output));\n        }\n        \n        if (verification_result == 0) {\n            if (test->expected_output[0] != '\\0') {\n                if (strstr(verification_output, test->expected_output) == NULL) {\n                    test->verification_success = 0;\n                    strncpy(test->details, verification_output, sizeof(test->details) - 1);\n                }\n            }\n        } else {\n            test->verification_success = 0;\n            strcpy(test->details, "Verification command failed");\n        }\n    }\n    \n    int overall_success = test->success && test->verification_success;\n    \n    if (overall_success) {\n        stats.passed_tests++;\n        printf("[" GREEN "PASS" RESET "]");\n    } else {\n        stats.failed_tests++;\n        if (test->critical) stats.critical_failures++;\n        printf("[" RED "FAIL" RESET "]");\n    }\n    \n    printf(" %s%4lld ms%s\\n", CYAN, test->duration_ms, RESET);\n    \n    if (!overall_success && verbose_mode) {\n        printf(RED "  [VERBOSE] FAILURE: %s\\n" RESET, test->details);\n    }\n    \n    stats.categories_total[test->category]++;\n    if (overall_success) stats.categories_passed[test->category]++;\n    \n    return overall_success;\n}\n\n// ==================== HTTP CLIENT IMPLEMENTATION (Enhanced) ====================\n\nHttpResponse* http_request(const char* method, const char* url, const char* body, const char* content_type) {\n    HttpResponse* response = malloc(sizeof(HttpResponse));\n    if (!response) return NULL;\n    \n    memset(response, 0, sizeof(HttpResponse));\n    \n    char full_url[1024];\n    if (strncmp(url, "http://", 7) != 0 && strncmp(url, "https://", 8) != 0) {\n        snprintf(full_url, sizeof(full_url), "%s%s", server_url, url);\n    } else {\n        strncpy(full_url, url, sizeof(full_url) - 1);\n    }\n    \n    char host[256] = "localhost";\n    int port = 8080;\n    char path[1024] = "/";\n    \n    if (strncmp(full_url, "http://", 7) == 0) {\n        const char* host_start = full_url + 7;\n        const char* path_start = strchr(host_start, '/');\n        const char* port_start = strchr(host_start, ':');\n        \n        if (port_start && (!path_start || port_start < path_start)) {\n            size_t host_len = port_start - host_start;\n            strncpy(host, host_start, host_len);\n            host[host_len] = '\\0';\n            port = atoi(port_start + 1);\n            if (path_start) strcpy(path, path_start);\n        } else if (path_start) {\n            size_t host_len = path_start - host_start;\n            strncpy(host, host_start, host_len);\n            host[host_len] = '\\0';\n            strcpy(path, path_start);\n        } else {\n            strcpy(host, host_start);\n        }\n    }\n    \n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0) {\n        free(response);\n        return NULL;\n    }\n    \n    struct timeval timeout;\n    timeout.tv_sec = 30;\n    timeout.tv_usec = 0;\n    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));\n    \n    struct hostent* server = gethostbyname(host);\n    if (!server) {\n        close(sockfd);\n        free(response);\n        return NULL;\n    }\n    \n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);\n    serv_addr.sin_port = htons(port);\n    \n    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) < 0) {\n        close(sockfd);\n        free(response);\n        return NULL;\n    }\n    \n    char request[16384];\n    int request_len;\n    \n    if (body && content_type) {\n        request_len = snprintf(request, sizeof(request),\n            "%s %s HTTP/1.1\\r\\n"\n            "Host: %s:%d\\r\\n"\n            "Content-Type: %s\\r\\n"\n            "Content-Length: %zu\\r\\n"\n            "Connection: close\\r\\n"\n            "\\r\\n"\n            "%s",\n            method, path, host, port, content_type, strlen(body), body);\n    } else if (body) {\n        request_len = snprintf(request, sizeof(request),\n            "%s %s HTTP/1.1\\r\\n"\n            "Host: %s:%d\\r\\n"\n            "Content-Length: %zu\\r\\n"\n            "Connection: close\\r\\n"\n            "\\r\\n"\n            "%s",\n            method, path, host, port, strlen(body), body);\n    } else {\n        request_len = snprintf(request, sizeof(request),\n            "%s %s HTTP/1.1\\r\\n"\n            "Host: %s:%d\\r\\n"\n            "Connection: close\\r\\n"\n            "\\r\\n",\n            method, path, host, port);\n    }\n    \n    if (send(sockfd, request, request_len, 0) < 0) {\n        close(sockfd);\n        free(response);\n        return NULL;\n    }\n    \n    char response_buffer[65536];\n    ssize_t total_received = 0;\n    ssize_t received;\n    \n    while ((received = recv(sockfd, response_buffer + total_received, \n                           sizeof(response_buffer) - total_received - 1, 0)) > 0) {\n        total_received += received;\n        if (total_received >= (ssize_t)sizeof(response_buffer) - 1) break;\n    }\n    \n    response_buffer[total_received] = '\\0';\n    close(sockfd);\n    \n    char* status_line = strstr(response_buffer, "HTTP/1.1");\n    if (status_line) {\n        sscanf(status_line, "HTTP/1.1 %d", &response->status_code);\n    }\n    \n    char* body_start = strstr(response_buffer, "\\r\\n\\r\\n");\n    if (body_start) {\n        body_start += 4;\n        response->body_length = total_received - (body_start - response_buffer);\n        response->body = malloc(response->body_length + 1);\n        if (response->body) {\n            memcpy(response->body, body_start, response->body_length);\n            response->body[response->body_length] = '\\0';\n        }\n    } else {\n        response->body = strdup("");\n        response->body_length = 0;\n    }\n    \n    return response;\n}\n\nvoid http_response_free(HttpResponse* response) {\n    if (response) {\n        if (response->body) free(response->body);\n        for (int i = 0; i < response->header_count; i++) {\n            free(response->headers[i]);\n        }\n        free(response);\n    }\n}\n\nint verify_http_response(const HttpResponse* response, const char* expected_pattern, int check_success_only) {\n    if (!response) return 0;\n    \n    if (check_success_only) {\n        return (response->status_code >= 200 && response->status_code < 500) && \n               response->body && strstr(response->body, "\\"success\\":") != NULL;\n    } else {\n        if (response->status_code < 200 || response->status_code >= 300) return 0;\n        if (expected_pattern && expected_pattern[0] != '\\0') {\n            if (!response->body || strstr(response->body, expected_pattern) == NULL) return 0;\n        }\n    }\n    return 1;\n}\n\nchar* extract_json_field(const char* json, const char* field) {\n    if (!json || !field) return NULL;\n    \n    char search_pattern[256];\n    snprintf(search_pattern, sizeof(search_pattern), "\\"%s\\":\\"", field);\n    \n    char* field_start = strstr(json, search_pattern);\n    if (!field_start) {\n        snprintf(search_pattern, sizeof(search_pattern), "\\"%s\\":", field);\n        field_start = strstr(json, search_pattern);\n        if (!field_start) return NULL;\n        \n        field_start += strlen(search_pattern);\n        char* field_end = strchr(field_start, ',');\n        if (!field_end) field_end = strchr(field_start, '}');\n        if (!field_end) return NULL;\n        \n        size_t field_length = field_end - field_start;\n        char* value = malloc(field_length + 1);\n        if (value) {\n            strncpy(value, field_start, field_length);\n            value[field_length] = '\\0';\n        }\n        return value;\n    }\n    \n    field_start += strlen(search_pattern);\n    char* field_end = strchr(field_start, '"');\n    if (!field_end) return NULL;\n    \n    size_t field_length = field_end - field_start;\n    char* value = malloc(field_length + 1);\n    if (value) {\n        strncpy(value, field_start, field_length);\n        value[field_length] = '\\0';\n    }\n    return value;\n}\n\nint http_test_endpoint(const char* description, const char* method, const char* endpoint, \n                      const char* body, const char* expected_pattern, int check_success_only, \n                      long long* duration, int category, int critical) {\n    stats.total_tests++;\n    stats.categories_total[category]++;\n    \n    printf("\\n%s%-80s" RESET, BLUE, description);\n    fflush(stdout);\n    \n    long long start_time = get_current_time_ms();\n    \n    HttpResponse* response = http_request(method, endpoint, body, "application/json");\n    long long end_time = get_current_time_ms();\n    long long elapsed = end_time - start_time;\n    \n    if (duration) *duration = elapsed;\n    stats.total_duration += elapsed;\n    \n    int success = 0;\n    if (response) {\n        success = verify_http_response(response, expected_pattern, check_success_only);\n        \n        if (success) {\n            stats.passed_tests++;\n            stats.categories_passed[category]++;\n            printf("[" GREEN "PASS" RESET "] %s%4lld ms%s\\n", CYAN, elapsed, RESET);\n        } else {\n            stats.failed_tests++;\n            if (critical) stats.critical_failures++;\n            printf("[" RED "FAIL" RESET "] %s%4lld ms%s\\n", CYAN, elapsed, RESET);\n            if (verbose_mode) {\n                printf(RED "  [VERBOSE] Status: %d, Body: %.100s\\n" RESET, \n                       response->status_code, response->body ? response->body : "NULL");\n            }\n        }\n        http_response_free(response);\n    } else {\n        stats.failed_tests++;\n        if (critical) stats.critical_failures++;\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s\\n", CYAN, elapsed, RESET);\n        printf(RED "  No response from server\\n" RESET);\n    }\n    \n    return success;\n}\n\n// ==================== SERVER MANAGEMENT ====================\n\nint start_sydb_server() {\n    printf("Starting SYDB server on port 8080...\\n");\n    \n    server_pid = fork();\n    if (server_pid == 0) {\n        // Child process\n        char* args[4];\n        args[0] = cli_command;\n        args[1] = "--server";\n        args[2] = verbose_mode ? "--verbose" : NULL;\n        args[3] = NULL;\n        \n        execvp(args[0], args);\n        exit(1);\n    } else if (server_pid > 0) {\n        // Parent process - wait for server to be ready\n        server_started_by_test = 1;\n        msleep(500); // Give server time to start\n        \n        if (wait_for_server_ready(10)) {\n            printf(GREEN "Server started successfully (PID: %d)\\n" RESET, server_pid);\n            return 1;\n        } else {\n            printf(RED "Server failed to start\\n" RESET);\n            kill(server_pid, SIGTERM);\n            server_pid = 0;\n            return 0;\n        }\n    }\n    \n    return 0;\n}\n\nint stop_sydb_server() {\n    if (server_pid > 0 && server_started_by_test) {\n        printf("Stopping SYDB server (PID: %d)...\\n", server_pid);\n        kill(server_pid, SIGTERM);\n        waitpid(server_pid, NULL, 0);\n        server_pid = 0;\n        server_started_by_test = 0;\n        msleep(200);\n        printf(GREEN "Server stopped\\n" RESET);\n        return 1;\n    }\n    return 0;\n}\n\nint wait_for_server_ready(int timeout_seconds) {\n    printf("Waiting for server to be ready...\\n");\n    \n    for (int i = 0; i < timeout_seconds * 10; i++) {\n        HttpResponse* response = http_request("GET", "/api/databases", NULL, NULL);\n        if (response && response->status_code > 0) {\n            http_response_free(response);\n            printf(GREEN "Server is ready\\n" RESET);\n            return 1;\n        }\n        http_response_free(response);\n        msleep(100);\n    }\n    \n    return 0;\n}\n\n// ==================== DURABILITY TESTS (CRITICAL) ====================\n\nint run_durability_tests_cli() {\n    printf("\\n" MAGENTA BOLD "DURABILITY & CRASH RECOVERY TESTS (CLI)" RESET "\\n");\n    printf(YELLOW "These tests verify data survives crashes and power failures\\n" RESET);\n    \n    int passed = 0;\n    int total = 0;\n    \n    // Create test database with unique name\n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "durability_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    \n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int --data-string > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // TEST 1: Insert with fsync verification\n    {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 1: Insert with immediate durability");\n        fflush(stdout);\n        \n        // Insert record\n        char insert_cmd[512];\n        snprintf(insert_cmd, sizeof(insert_cmd), \n                 "%s create %s users --insert-one --name-\\"Durable User\\" --age-25 --data-\\"Test data\\" > /dev/null 2>&1",\n                 cli_command, db_name);\n        \n        long long start = get_current_time_ms();\n        int result = system(insert_cmd);\n        long long duration = get_current_time_ms() - start;\n        stats.total_duration += duration;\n        \n        // Force sync to disk (test if fsync is called)\n        char sync_cmd[256];\n        snprintf(sync_cmd, sizeof(sync_cmd), "sync");\n        system(sync_cmd);\n        \n        // Check if record exists\n        int count = count_instances_in_collection(db_name, "users");\n        \n        if (result == 0 && count >= 1) {\n            printf("[" GREEN "PASS" RESET "] %s%4lld ms%s\\n", CYAN, duration, RESET);\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_DURABILITY]++;\n            passed++;\n        } else {\n            printf("[" RED "FAIL" RESET "] %s%4lld ms%s\\n", CYAN, duration, RESET);\n            printf(RED "  Record not found after insert\\n" RESET);\n            stats.failed_tests++;\n            stats.critical_failures++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_DURABILITY]++;\n    }\n    \n    // TEST 2: Crash during insert - recovery test\n    {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 2: Crash recovery - kill during insert");\n        fflush(stdout);\n        \n        // Only run this test in comprehensive mode\n        if (test_level >= 2) {\n            long long start = get_current_time_ms();\n            \n            // Fork a child to simulate crash\n            pid_t child_pid = fork();\n            \n            if (child_pid == 0) {\n                // Child - perform insert and crash\n                char insert_cmd[512];\n                snprintf(insert_cmd, sizeof(insert_cmd),\n                        "%s create %s users --insert-one --name-\\"Crash Test\\" --age-99 --data-\\"Should recover\\" > /dev/null 2>&1",\n                        cli_command, db_name);\n                \n                system(insert_cmd);\n                \n                // Simulate crash - don't clean up\n                exit(0);\n            } else {\n                // Parent - wait for child\n                int status;\n                waitpid(child_pid, &status, 0);\n                \n                // Check if data survived\n                msleep(500); // Give system time to settle\n                \n                int count = count_instances_in_collection(db_name, "users");\n                \n                long long duration = get_current_time_ms() - start;\n                stats.total_duration += duration;\n                \n                // We don't know if it should survive - just report what happened\n                if (count >= 2) { // We had 1 from previous test\n                    printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Data survived crash\\n", CYAN, duration, RESET);\n                    passed++;\n                    stats.passed_tests++;\n                    stats.categories_passed[CATEGORY_DURABILITY]++;\n                } else {\n                    printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - Data lost on crash (fsync missing?)\\n", CYAN, duration, RESET);\n                    // Not marking as fail because we're just documenting behavior\n                    stats.skipped_tests++;\n                }\n                stats.total_tests++;\n                stats.categories_total[CATEGORY_DURABILITY]++;\n            }\n        } else {\n            printf("[" YELLOW "SKIP" RESET "] %s%4lld ms%s\\n", CYAN, 0, RESET);\n            printf(YELLOW "  Skipped (use --level=2 for comprehensive testing)\\n" RESET);\n            stats.skipped_tests++;\n        }\n    }\n    \n    // TEST 3: Power failure simulation - file system consistency\n    {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 3: File system consistency after abnormal termination");\n        fflush(stdout);\n        \n        if (test_level >= 2) {\n            long long start = get_current_time_ms();\n            \n            // Get file path\n            char data_path[512];\n            snprintf(data_path, sizeof(data_path), "/tmp/sydb_test/%s/users/data.sydb", db_name);\n            \n            // Get checksum before\n            int checksum_before = calculate_file_checksum(data_path);\n            int size_before = get_file_size(data_path);\n            \n            // Fork and kill -9\n            pid_t child_pid = fork();\n            \n            if (child_pid == 0) {\n                // Child - perform multiple inserts\n                for (int i = 0; i < 10; i++) {\n                    char insert_cmd[512];\n                    snprintf(insert_cmd, sizeof(insert_cmd),\n                            "%s create %s users --insert-one --name-\\"Bulk%d\\" > /dev/null 2>&1",\n                            cli_command, db_name, i);\n                    system(insert_cmd);\n                }\n                exit(0);\n            } else {\n                // Don't wait - kill immediately\n                usleep(50000); // 50ms\n                kill(child_pid, SIGKILL);\n                waitpid(child_pid, NULL, 0);\n                \n                msleep(200);\n                \n                // Check file integrity\n                int checksum_after = calculate_file_checksum(data_path);\n                int size_after = get_file_size(data_path);\n                \n                long long duration = get_current_time_ms() - start;\n                stats.total_duration += duration;\n                \n                // File should still be readable\n                int count = count_instances_in_collection(db_name, "users");\n                \n                if (count > 0) {\n                    printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - File readable, %d records\\n", \n                           CYAN, duration, RESET, count);\n                    passed++;\n                    stats.passed_tests++;\n                    stats.categories_passed[CATEGORY_DURABILITY]++;\n                } else {\n                    printf("[" RED "FAIL" RESET "] %s%4lld ms%s - File corrupted\\n", CYAN, duration, RESET);\n                    stats.failed_tests++;\n                    stats.critical_failures++;\n                }\n                stats.total_tests++;\n                stats.categories_total[CATEGORY_DURABILITY]++;\n            }\n        } else {\n            printf("[" YELLOW "SKIP" RESET "] %s%4lld ms%s\\n", CYAN, 0, RESET);\n            stats.skipped_tests++;\n        }\n    }\n    \n    // TEST 4: Concurrent durability - many inserts, then verify count\n    {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 4: Bulk insert durability (100 records)");\n        fflush(stdout);\n        \n        long long start = get_current_time_ms();\n        \n        int success_count = 0;\n        for (int i = 0; i < 100; i++) {\n            char insert_cmd[512];\n            snprintf(insert_cmd, sizeof(insert_cmd),\n                    "%s create %s users --insert-one --name-\\"BulkUser%d\\" --age-%d > /dev/null 2>&1",\n                    cli_command, db_name, i, 20 + (i % 50));\n            if (system(insert_cmd) == 0) success_count++;\n        }\n        \n        // Force sync\n        system("sync");\n        \n        int final_count = count_instances_in_collection(db_name, "users");\n        long long duration = get_current_time_ms() - start;\n        stats.total_duration += duration;\n        \n        if (final_count >= success_count && success_count > 90) {\n            printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - %d/%d records persisted\\n", \n                   CYAN, duration, RESET, final_count, success_count);\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_DURABILITY]++;\n        } else {\n            printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Only %d/%d records persisted\\n", \n                   CYAN, duration, RESET, final_count, success_count);\n            stats.failed_tests++;\n            stats.critical_failures++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_DURABILITY]++;\n    }\n    \n    printf(YELLOW "  Durability tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_durability_tests_http() {\n    printf("\\n" MAGENTA BOLD "DURABILITY & CRASH RECOVERY TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long duration;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "http_durability_%ld", time(NULL));\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    \n    // Create database\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    // Create collection\n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    // TEST 1: Insert and verify\n    total++;\n    const char* user1 = "{\\"name\\":\\"Durable User\\",\\"age\\":30}";\n    if (http_test_endpoint("HTTP: Insert with durability verification", \n                          "POST", instances_url, user1, "\\"success\\":true", 0, &duration,\n                          CATEGORY_DURABILITY, 1)) {\n        passed++;\n    }\n    \n    // TEST 2: Multiple inserts under load\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "HTTP: Bulk insert durability (50 records)");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    int success_count = 0;\n    \n    for (int i = 0; i < 50; i++) {\n        char user_json[256];\n        snprintf(user_json, sizeof(user_json), "{\\"name\\":\\"User%d\\",\\"age\\":%d}", i, 20 + i);\n        HttpResponse* r = http_request("POST", instances_url, user_json, "application/json");\n        if (r && r->status_code >= 200 && r->status_code < 300) success_count++;\n        http_response_free(r);\n    }\n    \n    long long elapsed = get_current_time_ms() - start;\n    stats.total_duration += elapsed;\n    \n    // Verify via GET\n    HttpResponse* verify_resp = http_request("GET", instances_url, NULL, NULL);\n    int record_count = 0;\n    if (verify_resp && verify_resp->body) {\n        char* pos = verify_resp->body;\n        while ((pos = strstr(pos, "\\"_id\\"")) != NULL) {\n            record_count++;\n            pos += 5;\n        }\n    }\n    http_response_free(verify_resp);\n    \n    if (record_count >= success_count && success_count > 45) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - %d/%d records\\n", CYAN, elapsed, RESET, record_count, success_count);\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_DURABILITY]++;\n        passed++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Only %d/%d records\\n", CYAN, elapsed, RESET, record_count, success_count);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_DURABILITY]++;\n    \n    printf(YELLOW "  HTTP Durability tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== CONCURRENCY TESTS ====================\n\n// Thread function for concurrent inserts\nvoid* concurrent_insert_thread(void* arg) {\n    ThreadTestContext* ctx = (ThreadTestContext*)arg;\n    ctx->success_count = 0;\n    long long start = get_current_time_ms();\n    \n    for (int i = 0; i < ctx->operations_count; i++) {\n        char command[512];\n        snprintf(command, sizeof(command), \n                "%s create %s %s --insert-one --name-\\"Thread%d_%d\\" --age-%d > /dev/null 2>&1",\n                cli_command, ctx->database, ctx->collection, ctx->thread_id, i, 20 + (i % 50));\n        \n        if (system(command) == 0) {\n            ctx->success_count++;\n        }\n        \n        // Small yield to increase interleaving\n        if (i % 10 == 0) usleep(100);\n    }\n    \n    ctx->total_time = get_current_time_ms() - start;\n    return NULL;\n}\n\nint run_concurrency_tests_cli() {\n    printf("\\n" MAGENTA BOLD "CONCURRENCY & THREAD SAFETY TESTS (CLI)" RESET "\\n");\n    printf(YELLOW "These tests verify the database handles concurrent access correctly\\n" RESET);\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "concurrency_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // TEST 1: Two threads concurrent inserts\n    if (test_level >= 1) {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 1: Two threads - 100 inserts each");\n        fflush(stdout);\n        \n        pthread_t threads[2];\n        ThreadTestContext contexts[2];\n        \n        for (int i = 0; i < 2; i++) {\n            memset(&contexts[i], 0, sizeof(ThreadTestContext));\n            strcpy(contexts[i].database, db_name);\n            strcpy(contexts[i].collection, "users");\n            contexts[i].thread_id = i;\n            contexts[i].operations_count = 100;\n        }\n        \n        long long start = get_current_time_ms();\n        \n        for (int i = 0; i < 2; i++) {\n            pthread_create(&threads[i], NULL, concurrent_insert_thread, &contexts[i]);\n        }\n        \n        for (int i = 0; i < 2; i++) {\n            pthread_join(threads[i], NULL);\n        }\n        \n        long long duration = get_current_time_ms() - start;\n        stats.total_duration += duration;\n        \n        int total_success = contexts[0].success_count + contexts[1].success_count;\n        int final_count = count_instances_in_collection(db_name, "users");\n        \n        printf(" - %d/%d ms\\n", (int)duration, 0);\n        \n        if (final_count == total_success && total_success == 200) {\n            printf("  [" GREEN "PASS" RESET "] All %d records inserted successfully\\n", total_success);\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_CONCURRENCY]++;\n        } else {\n            printf("  [" RED "FAIL" RESET "] Expected %d records, got %d (successful inserts: %d)\\n", \n                   200, final_count, total_success);\n            stats.failed_tests++;\n            stats.critical_failures++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_CONCURRENCY]++;\n    }\n    \n    // TEST 2: Reader/Writer concurrency\n    {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 2: Readers don't block writers");\n        fflush(stdout);\n        \n        long long start = get_current_time_ms();\n        \n        // Start a long read operation in background\n        pid_t reader_pid = fork();\n        \n        if (reader_pid == 0) {\n            // Child - long running list operation\n            char list_cmd[512];\n            snprintf(list_cmd, sizeof(list_cmd), \n                    "%s list %s users > /dev/null 2>&1", cli_command, db_name);\n            \n            for (int i = 0; i < 10; i++) {\n                system(list_cmd);\n                usleep(10000);\n            }\n            exit(0);\n        } else {\n            // Parent - perform writes while read is happening\n            msleep(50); // Let reader start\n            \n            int write_success = 0;\n            for (int i = 0; i < 20; i++) {\n                char insert_cmd[512];\n                snprintf(insert_cmd, sizeof(insert_cmd),\n                        "%s create %s users --insert-one --name-\\"RW%d\\" > /dev/null 2>&1",\n                        cli_command, db_name, i);\n                if (system(insert_cmd) == 0) write_success++;\n                usleep(5000);\n            }\n            \n            kill(reader_pid, SIGTERM);\n            waitpid(reader_pid, NULL, 0);\n            \n            long long duration = get_current_time_ms() - start;\n            stats.total_duration += duration;\n            \n            int final_count = count_instances_in_collection(db_name, "users");\n            \n            printf(" - %lld ms\\n", duration);\n            \n            if (write_success >= 18) {\n                printf("  [" GREEN "PASS" RESET "] Writers completed while readers active: %d/%d\\n", \n                       write_success, 20);\n                passed++;\n                stats.passed_tests++;\n                stats.categories_passed[CATEGORY_CONCURRENCY]++;\n            } else {\n                printf("  [" YELLOW "WARN" RESET "] Writers blocked by readers: only %d/%d succeeded\\n", \n                       write_success, 20);\n                stats.skipped_tests++;\n            }\n            stats.total_tests++;\n            stats.categories_total[CATEGORY_CONCURRENCY]++;\n        }\n    }\n    \n    // TEST 3: High concurrency - 10 threads\n    if (test_level >= 2) {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "TEST 3: 10 threads - 50 inserts each (high concurrency)");\n        fflush(stdout);\n        \n        #define THREAD_COUNT 10\n        pthread_t threads[THREAD_COUNT];\n        ThreadTestContext contexts[THREAD_COUNT];\n        \n        for (int i = 0; i < THREAD_COUNT; i++) {\n            memset(&contexts[i], 0, sizeof(ThreadTestContext));\n            strcpy(contexts[i].database, db_name);\n            strcpy(contexts[i].collection, "users");\n            contexts[i].thread_id = i;\n            contexts[i].operations_count = 50;\n        }\n        \n        long long start = get_current_time_ms();\n        \n        for (int i = 0; i < THREAD_COUNT; i++) {\n            pthread_create(&threads[i], NULL, concurrent_insert_thread, &contexts[i]);\n        }\n        \n        for (int i = 0; i < THREAD_COUNT; i++) {\n            pthread_join(threads[i], NULL);\n        }\n        \n        long long duration = get_current_time_ms() - start;\n        stats.total_duration += duration;\n        \n        int total_success = 0;\n        for (int i = 0; i < THREAD_COUNT; i++) {\n            total_success += contexts[i].success_count;\n        }\n        \n        int final_count = count_instances_in_collection(db_name, "users");\n        \n        printf(" - %lld ms\\n", duration);\n        \n        if (final_count == total_success && total_success >= (THREAD_COUNT * 50 * 0.9)) {\n            printf("  [" GREEN "PASS" RESET "] %d/%d records inserted successfully\\n", \n                   final_count, THREAD_COUNT * 50);\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_CONCURRENCY]++;\n        } else {\n            printf("  [" RED "FAIL" RESET "] Expected ~%d, got %d (successful: %d)\\n", \n                   THREAD_COUNT * 50, final_count, total_success);\n            stats.failed_tests++;\n            stats.critical_failures++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_CONCURRENCY]++;\n    }\n    \n    printf(YELLOW "  Concurrency tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// HTTP concurrency test thread\nvoid* http_concurrent_thread(void* arg) {\n    ThreadTestContext* ctx = (ThreadTestContext*)arg;\n    ctx->success_count = 0;\n    long long start = get_current_time_ms();\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), \n             "/api/databases/%s/collections/%s/instances", \n             ctx->database, ctx->collection);\n    \n    for (int i = 0; i < ctx->operations_count; i++) {\n        char user_json[256];\n        snprintf(user_json, sizeof(user_json), \n                "{\\"name\\":\\"HTTP_Thread%d_%d\\",\\"age\\":%d}", \n                ctx->thread_id, i, 20 + (i % 50));\n        \n        HttpResponse* resp = http_request("POST", instances_url, user_json, "application/json");\n        if (resp && resp->status_code >= 200 && resp->status_code < 300) {\n            ctx->success_count++;\n        }\n        http_response_free(resp);\n        \n        if (i % 10 == 0) usleep(50);\n    }\n    \n    ctx->total_time = get_current_time_ms() - start;\n    return NULL;\n}\n\nint run_concurrency_tests_http() {\n    printf("\\n" MAGENTA BOLD "CONCURRENCY & THREAD SAFETY TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    if (test_level < 1) {\n        printf(YELLOW "  Skipping HTTP concurrency tests (use --level=1 or higher)\\n" RESET);\n        return 0;\n    }\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "http_conc_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    // TEST: Concurrent HTTP requests\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "HTTP: 5 concurrent threads - 25 inserts each");\n    fflush(stdout);\n    \n    #define HTTP_THREAD_COUNT 5\n    pthread_t threads[HTTP_THREAD_COUNT];\n    ThreadTestContext contexts[HTTP_THREAD_COUNT];\n    \n    for (int i = 0; i < HTTP_THREAD_COUNT; i++) {\n        memset(&contexts[i], 0, sizeof(ThreadTestContext));\n        strcpy(contexts[i].database, db_name);\n        strcpy(contexts[i].collection, "users");\n        contexts[i].thread_id = i;\n        contexts[i].operations_count = 25;\n    }\n    \n    long long start = get_current_time_ms();\n    \n    for (int i = 0; i < HTTP_THREAD_COUNT; i++) {\n        pthread_create(&threads[i], NULL, http_concurrent_thread, &contexts[i]);\n    }\n    \n    for (int i = 0; i < HTTP_THREAD_COUNT; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    int total_success = 0;\n    for (int i = 0; i < HTTP_THREAD_COUNT; i++) {\n        total_success += contexts[i].success_count;\n    }\n    \n    // Verify count via GET\n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    HttpResponse* verify_resp = http_request("GET", instances_url, NULL, NULL);\n    \n    int record_count = 0;\n    if (verify_resp && verify_resp->body) {\n        char* pos = verify_resp->body;\n        while ((pos = strstr(pos, "\\"_id\\"")) != NULL) {\n            record_count++;\n            pos += 5;\n        }\n    }\n    http_response_free(verify_resp);\n    \n    printf(" - %lld ms\\n", duration);\n    \n    if (record_count == total_success && total_success >= (HTTP_THREAD_COUNT * 25 * 0.9)) {\n        printf("  [" GREEN "PASS" RESET "] HTTP concurrency: %d/%d records\\n", record_count, total_success);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_CONCURRENCY]++;\n    } else {\n        printf("  [" RED "FAIL" RESET "] Expected %d, got %d records\\n", \n               HTTP_THREAD_COUNT * 25, record_count);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_CONCURRENCY]++;\n    \n    printf(YELLOW "  HTTP Concurrency tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== QUERY LANGUAGE TESTS ====================\n\nint run_query_language_tests_cli() {\n    printf("\\n" MAGENTA BOLD "QUERY LANGUAGE & INDEXING TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "query_test_%ld", time(NULL));\n    \n    // Setup with indexed fields\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    \n    // Create collection with indexed fields\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req-idx --age-int-idx --email-string --salary-float > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // Insert test data\n    for (int i = 0; i < 50; i++) {\n        char insert_cmd[512];\n        snprintf(insert_cmd, sizeof(insert_cmd),\n                "%s create %s users --insert-one --name-\\"User%d\\" --age-%d --email-\\"user%d@test.com\\" --salary-%.2f > /dev/null 2>&1",\n                cli_command, db_name, i, 20 + (i % 30), i, 30000.0 + i * 1000.0);\n        system(insert_cmd);\n    }\n    \n    // TEST 1: Equality query (existing functionality)\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 1: Equality query - age:25");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    char query_cmd[512];\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age:25\\" | grep -c User", cli_command, db_name);\n    \n    char output[256];\n    execute_command_and_capture(query_cmd, output, sizeof(output));\n    int count = atoi(output);\n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (count > 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Found %d records\\n", CYAN, duration, RESET, count);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - No results\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    // TEST 2: Greater than query (SHOULD FAIL - feature missing)\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 2: Greater than query - age>30 (feature test)");\n    fflush(stdout);\n    \n    // This should fail - SyDB doesn't support > operator\n    // We're testing if it fails gracefully\n    start = get_current_time_ms();\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age>30\\" 2>&1 | grep -i 'error\\\\|invalid'", cli_command, db_name);\n    \n    int error_detected = (system(query_cmd) == 0);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (error_detected) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Unsupported operator properly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - > operator not rejected (may be implemented?)\\n", CYAN, duration, RESET);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    // TEST 3: Less than query\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 3: Less than query - age<25 (feature test)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age<25\\" 2>&1 | grep -i 'error\\\\|invalid'", cli_command, db_name);\n    \n    error_detected = (system(query_cmd) == 0);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (error_detected) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Unsupported operator properly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - < operator not rejected\\n", CYAN, duration, RESET);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    // TEST 4: AND query (comma-separated - existing)\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 4: AND query - age:25,name:User1");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age:25,name:User1\\" | grep -c User1", cli_command, db_name);\n    \n    execute_command_and_capture(query_cmd, output, sizeof(output));\n    count = atoi(output);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    // This should find User1 if age=25\n    if (count >= 0) { // Just verify it runs without error\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Query executed\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Query failed\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    // TEST 5: OR query (feature test - SHOULD FAIL)\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 5: OR query - age:25 OR age:30 (feature test)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age:25 OR age:30\\" 2>&1 | grep -i 'error\\\\|invalid'", cli_command, db_name);\n    \n    error_detected = (system(query_cmd) == 0);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (error_detected) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Unsupported OR properly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - OR operator not rejected\\n", CYAN, duration, RESET);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    // TEST 6: Range query (feature test)\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 6: Range query - age:25-35 (feature test)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(query_cmd, sizeof(query_cmd), \n             "%s find %s users --where \\"age:25-35\\" 2>&1 | grep -i 'error\\\\|invalid'", cli_command, db_name);\n    \n    error_detected = (system(query_cmd) == 0);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (error_detected) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Unsupported range properly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_QUERY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - Range operator not rejected\\n", CYAN, duration, RESET);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_QUERY]++;\n    \n    printf(YELLOW "  Query language tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_query_language_tests_http() {\n    printf("\\n" MAGENTA BOLD "QUERY LANGUAGE TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long duration;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "http_query_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"},"\n        "{\\"name\\":\\"salary\\",\\"type\\":\\"float\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    // Insert test data\n    for (int i = 0; i < 20; i++) {\n        char user_json[256];\n        snprintf(user_json, sizeof(user_json), \n                "{\\"name\\":\\"HTTPUser%d\\",\\"age\\":%d,\\"salary\\":%.2f}", \n                i, 20 + (i % 20), 30000.0 + i * 1000.0);\n        resp = http_request("POST", instances_url, user_json, "application/json");\n        http_response_free(resp);\n    }\n    \n    // TEST: Equality query\n    total++;\n    char query_url[512];\n    snprintf(query_url, sizeof(query_url), \n             "/api/databases/%s/collections/users/instances?query=age:25", db_name);\n    \n    if (http_test_endpoint("HTTP: Equality query - age:25", \n                          "GET", query_url, NULL, "\\"instances\\":", 0, &duration,\n                          CATEGORY_QUERY, 0)) {\n        passed++;\n    }\n    \n    // TEST: Non-existent value\n    total++;\n    snprintf(query_url, sizeof(query_url), \n             "/api/databases/%s/collections/users/instances?query=age:999", db_name);\n    \n    if (http_test_endpoint("HTTP: Query with no matches", \n                          "GET", query_url, NULL, "\\"instances\\":[]", 0, &duration,\n                          CATEGORY_QUERY, 0)) {\n        passed++;\n    }\n    \n    printf(YELLOW "  HTTP Query tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== SCHEMA ENFORCEMENT TESTS ====================\n\nint run_schema_enforcement_tests_cli() {\n    printf("\\n" MAGENTA BOLD "SCHEMA ENFORCEMENT TESTS (CLI)" RESET "\\n");\n    printf(YELLOW "These tests verify that schemas are actually enforced\\n" RESET);\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "schema_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    \n    // Create collection with strict schema\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int --email-string-req --active-bool > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // TEST 1: Valid insert - should pass\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 1: Valid insert - all required fields");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    char insert_cmd[512];\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Valid User\\" --email-\\"valid@test.com\\" --age-30 --active-true > /dev/null 2>&1",\n            cli_command, db_name);\n    \n    int result = system(insert_cmd);\n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    int count = count_instances_in_collection(db_name, "users");\n    \n    if (result == 0 && count >= 1) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SCHEMA]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SCHEMA]++;\n    \n    // TEST 2: Missing required field - should FAIL\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 2: Missing required field 'name' (should be rejected)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --email-\\"missing@test.com\\" --age-30 > /dev/null 2>&1",\n            cli_command, db_name);\n    \n    result = system(insert_cmd);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    // Should fail - required field missing\n    if (result != 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Correctly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SCHEMA]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Accepted insert with missing required field!\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SCHEMA]++;\n    \n    // TEST 3: Wrong type - string for int field - should FAIL\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 3: Wrong type - string for age (should be rejected)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Type Test\\" --email-\\"type@test.com\\" --age-\\"thirty\\" --active-true > /dev/null 2>&1",\n            cli_command, db_name);\n    \n    result = system(insert_cmd);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (result != 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Correctly rejected\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SCHEMA]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Accepted string for integer field!\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SCHEMA]++;\n    \n    // TEST 4: Extra field not in schema - should this be allowed?\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 4: Extra field not in schema (document flexibility)");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Extra Field\\" --email-\\"extra@test.com\\" --age-25 --active-true --extra-\\"should this be allowed?\\" > /dev/null 2>&1",\n            cli_command, db_name);\n    \n    result = system(insert_cmd);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    // Document databases typically allow extra fields\n    // This is a design choice, not a bug\n    if (result == 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Extra fields allowed (document model)\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SCHEMA]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - Extra fields rejected (strict schema)\\n", CYAN, duration, RESET);\n        // Not marking as fail - this is a design decision\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SCHEMA]++;\n    \n    // TEST 5: Boolean validation\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "TEST 5: Invalid boolean value - should be true/false");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Bool Test\\" --email-\\"bool@test.com\\" --age-25 --active-yes > /dev/null 2>&1",\n            cli_command, db_name);\n    \n    result = system(insert_cmd);\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (result != 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Correctly rejected invalid boolean\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SCHEMA]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Accepted invalid boolean 'yes'\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SCHEMA]++;\n    \n    printf(YELLOW "  Schema enforcement tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_schema_enforcement_tests_http() {\n    printf("\\n" MAGENTA BOLD "SCHEMA ENFORCEMENT TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long duration;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "http_schema_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\",\\"required\\":true},"\n        "{\\"name\\":\\"email\\",\\"type\\":\\"string\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    // TEST 1: Valid insert\n    total++;\n    const char* valid_user = "{\\"name\\":\\"Valid User\\",\\"age\\":30,\\"email\\":\\"valid@test.com\\"}";\n    if (http_test_endpoint("HTTP: Valid insert - should succeed", \n                          "POST", instances_url, valid_user, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SCHEMA, 1)) {\n        passed++;\n    }\n    \n    // TEST 2: Missing required field - should FAIL\n    total++;\n    const char* missing_name = "{\\"age\\":30,\\"email\\":\\"missing@test.com\\"}";\n    if (http_test_endpoint("HTTP: Missing required field 'name' - should fail", \n                          "POST", instances_url, missing_name, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SCHEMA, 1)) {\n        passed++;\n    }\n    \n    // TEST 3: Wrong type - should FAIL\n    total++;\n    const char* wrong_type = "{\\"name\\":\\"Type Test\\",\\"age\\":\\"thirty\\",\\"email\\":\\"type@test.com\\"}";\n    if (http_test_endpoint("HTTP: Wrong type (string for int) - should fail", \n                          "POST", instances_url, wrong_type, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SCHEMA, 1)) {\n        passed++;\n    }\n    \n    printf(YELLOW "  HTTP Schema tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== SECURITY TESTS (ENHANCED) ====================\n\nint run_security_tests_cli() {\n    printf("\\n" MAGENTA BOLD "SECURITY & INJECTION TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    TestCase security_tests[] = {\n        {\n            "Directory traversal prevention - database name",\n            "%s create '../evil' 2>&1 | grep -i 'invalid\\\\|error' > /dev/null",\n            "test ! -d '/tmp/sydb_test/../evil'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "Directory traversal prevention - collection name", \n            "%s create testdb '../../evil' --schema --name-string 2>&1 | grep -i 'invalid\\\\|error' > /dev/null",\n            "test ! -d '/tmp/sydb_test/testdb/../../evil'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "Special characters in database names - rejection",\n            "%s create 'invalid/name' 2>&1 | grep -i 'invalid\\\\|error' > /dev/null",\n            "test ! -d '/tmp/sydb_test/invalid/name'", \n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "Command injection attempt - semicolon",\n            "%s create 'test; rm -rf /' 2>&1 | grep -i 'invalid\\\\|error' > /dev/null",\n            "echo 'Injection prevented'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "Command injection attempt - backticks",\n            "%s create 'test\`id\`' 2>&1 | grep -i 'invalid\\\\|error' > /dev/null", \n            "echo 'Injection prevented'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "SQL-like injection in query",\n            "%s find testdb users --where \\"name:' OR 1=1--\\" 2>&1 | grep -i 'error\\\\|invalid' > /dev/null",\n            "echo 'Injection handled'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        },\n        {\n            "Very long name - buffer overflow protection",\n            "%s create aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 2>&1 | grep -i 'invalid\\\\|error' > /dev/null",\n            "echo 'Long name rejected'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SECURITY, 1\n        }\n    };\n    \n    int security_count = sizeof(security_tests) / sizeof(security_tests[0]);\n    \n    for (int i = 0; i < security_count; i++) {\n        total++;\n        \n        char final_command[1024];\n        char final_verification[1024];\n        \n        snprintf(final_command, sizeof(final_command), security_tests[i].command, cli_command);\n        snprintf(final_verification, sizeof(final_verification), security_tests[i].verification_command, cli_command);\n        \n        strcpy(security_tests[i].command, final_command);\n        strcpy(security_tests[i].verification_command, final_verification);\n        \n        if (execute_test_with_verification(&security_tests[i])) {\n            passed++;\n        }\n    }\n    \n    printf(YELLOW "  Security tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_security_tests_http() {\n    printf("\\n" MAGENTA BOLD "SECURITY & INJECTION TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long duration;\n    \n    // Test 1: SQL injection in query parameter\n    total++;\n    if (http_test_endpoint("HTTP: SQL injection attempt in query", \n                          "GET", "/api/databases/testdb/collections/users/instances?query=name:' OR 1=1--", \n                          NULL, "\\"success\\":", 1, &duration,\n                          CATEGORY_SECURITY, 1)) {\n        passed++;\n    }\n    \n    // Test 2: JSON injection in body\n    total++;\n    const char* json_injection = "{\\"name\\":\\"\\\\\\"}, \\"malicious\\": true, \\"age\\":30}";\n    if (http_test_endpoint("HTTP: JSON injection attempt", \n                          "POST", "/api/databases", json_injection, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SECURITY, 1)) {\n        passed++;\n    }\n    \n    // Test 3: Path traversal\n    total++;\n    if (http_test_endpoint("HTTP: Path traversal attempt", \n                          "GET", "/api/databases/../etc/passwd", \n                          NULL, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SECURITY, 1)) {\n        passed++;\n    }\n    \n    // Test 4: Very long URL\n    total++;\n    char long_url[2048] = "/api/databases/";\n    for (int i = 0; i < 100; i++) {\n        strcat(long_url, "aaaaaaaaaa");\n    }\n    if (http_test_endpoint("HTTP: Very long URL (buffer overflow test)", \n                          "GET", long_url, NULL, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SECURITY, 1)) {\n        passed++;\n    }\n    \n    // Test 5: Invalid JSON\n    total++;\n    if (http_test_endpoint("HTTP: Malformed JSON", \n                          "POST", "/api/databases", "{name: test}", "\\"success\\":false", 1, &duration,\n                          CATEGORY_SECURITY, 1)) {\n        passed++;\n    }\n    \n    printf(YELLOW "  HTTP Security tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== PERFORMANCE TESTS ====================\n\nint run_performance_tests_cli() {\n    printf("\\n" MAGENTA BOLD "PERFORMANCE & SCALABILITY TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "perf_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string --age-int > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // TEST 1: Single insert performance\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "PERF 1: Single insert latency");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    char insert_cmd[512];\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Perf User\\" --age-30 > /dev/null 2>&1",\n            cli_command, db_name);\n    system(insert_cmd);\n    long long single_time = get_current_time_ms() - start;\n    stats.total_duration += single_time;\n    \n    printf(" - %lld ms\\n", single_time);\n    \n    if (single_time < 100) {\n        printf("  [" GREEN "PASS" RESET "] Insert latency: %lld ms\\n", single_time);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_PERFORMANCE]++;\n    } else {\n        printf("  [" YELLOW "WARN" RESET "] Insert latency high: %lld ms\\n", single_time);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    // TEST 2: Batch insert performance\n    if (test_level >= 1) {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "PERF 2: Batch insert - 100 records");\n        fflush(stdout);\n        \n        start = get_current_time_ms();\n        int success_count = 0;\n        \n        for (int i = 0; i < 100; i++) {\n            snprintf(insert_cmd, sizeof(insert_cmd),\n                    "%s create %s users --insert-one --name-\\"BatchUser%d\\" --age-%d > /dev/null 2>&1",\n                    cli_command, db_name, i, 20 + (i % 50));\n            if (system(insert_cmd) == 0) success_count++;\n        }\n        \n        long long batch_time = get_current_time_ms() - start;\n        stats.total_duration += batch_time;\n        double avg_time = (double)batch_time / success_count;\n        \n        printf(" - %lld ms (avg: %.2f ms/op)\\n", batch_time, avg_time);\n        \n        if (success_count >= 95) {\n            printf("  [" GREEN "PASS" RESET "] %d/100 inserts, avg %.2f ms\\n", success_count, avg_time);\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_PERFORMANCE]++;\n        } else {\n            printf("  [" YELLOW "WARN" RESET "] Only %d/100 inserts succeeded\\n", success_count);\n            stats.skipped_tests++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_PERFORMANCE]++;\n    }\n    \n    // TEST 3: Query performance\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "PERF 3: Query performance - exact match");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    char query_cmd[512];\n    snprintf(query_cmd, sizeof(query_cmd),\n            "%s find %s users --where \\"age:30\\" > /dev/null 2>&1",\n            cli_command, db_name);\n    system(query_cmd);\n    long long query_time = get_current_time_ms() - start;\n    stats.total_duration += query_time;\n    \n    printf(" - %lld ms\\n", query_time);\n    \n    if (query_time < 200) {\n        printf("  [" GREEN "PASS" RESET "] Query time: %lld ms\\n", query_time);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_PERFORMANCE]++;\n    } else {\n        printf("  [" YELLOW "WARN" RESET "] Query time high: %lld ms\\n", query_time);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    // TEST 4: Large dataset performance\n    if (test_level >= 2) {\n        total++;\n        printf("\\n%s%-80s" RESET, BLUE, "PERF 4: Large dataset - 1000 records");\n        fflush(stdout);\n        \n        start = get_current_time_ms();\n        \n        for (int i = 0; i < 1000; i++) {\n            snprintf(insert_cmd, sizeof(insert_cmd),\n                    "%s create %s users --insert-one --name-\\"LargeUser%d\\" --age-%d > /dev/null 2>&1",\n                    cli_command, db_name, i, 20 + (i % 50));\n            system(insert_cmd);\n            \n            if (i % 100 == 0) {\n                printf(".");\n                fflush(stdout);\n            }\n        }\n        \n        long long large_time = get_current_time_ms() - start;\n        stats.total_duration += large_time;\n        \n        int final_count = count_instances_in_collection(db_name, "users");\n        \n        printf(" - %lld ms, %d records\\n", large_time, final_count);\n        \n        if (final_count >= 1000) {\n            printf("  [" GREEN "PASS" RESET "] All 1000 records inserted\\n");\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_PERFORMANCE]++;\n        } else {\n            printf("  [" RED "FAIL" RESET "] Only %d/1000 records inserted\\n", final_count);\n            stats.failed_tests++;\n        }\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_PERFORMANCE]++;\n    }\n    \n    printf(YELLOW "  Performance tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_performance_tests_http() {\n    printf("\\n" MAGENTA BOLD "PERFORMANCE TESTS (HTTP)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    if (test_level < 1) {\n        printf(YELLOW "  Skipping HTTP performance tests (use --level=1 or higher)\\n" RESET);\n        return 0;\n    }\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "http_perf_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\"},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    // TEST: HTTP insert latency\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "HTTP PERF: Insert latency (10 inserts)");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    int success_count = 0;\n    \n    for (int i = 0; i < 10; i++) {\n        char user_json[256];\n        snprintf(user_json, sizeof(user_json), "{\\"name\\":\\"PerfUser%d\\",\\"age\\":%d}", i, 20 + i);\n        HttpResponse* r = http_request("POST", instances_url, user_json, "application/json");\n        if (r && r->status_code >= 200 && r->status_code < 300) success_count++;\n        http_response_free(r);\n    }\n    \n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    double avg_time = (double)duration / success_count;\n    \n    printf(" - %lld ms (avg: %.2f ms/op)\\n", duration, avg_time);\n    \n    if (success_count >= 9) {\n        printf("  [" GREEN "PASS" RESET "] HTTP insert latency: %.2f ms\\n", avg_time);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_PERFORMANCE]++;\n    } else {\n        printf("  [" YELLOW "WARN" RESET "] Only %d/10 inserts succeeded\\n", success_count);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    printf(YELLOW "  HTTP Performance tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== DATA INTEGRITY TESTS ====================\n\nint run_integrity_tests_cli() {\n    printf("\\n" MAGENTA BOLD "DATA INTEGRITY TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "integrity_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s data --schema --value-string > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    char insert_cmd[512];\n    \n    // Insert some data\n    for (int i = 0; i < 10; i++) {\n        snprintf(insert_cmd, sizeof(insert_cmd),\n                "%s create %s data --insert-one --value-\\"test_data_%d\\" > /dev/null 2>&1",\n                cli_command, db_name, i);\n        system(insert_cmd);\n    }\n    \n    // TEST 1: File header verification\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "INTEGRITY 1: Data file header verification");\n    fflush(stdout);\n    \n    char data_path[512];\n    snprintf(data_path, sizeof(data_path), "/tmp/sydb_test/%s/data/data.sydb", db_name);\n    \n    long long start = get_current_time_ms();\n    \n    char hexdump_cmd[512];\n    snprintf(hexdump_cmd, sizeof(hexdump_cmd), \n             "hexdump -C %s | head -1 | grep -q '53 59 44 42' 2>/dev/null", data_path);\n    \n    int header_ok = (system(hexdump_cmd) == 0);\n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    if (header_ok) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Valid header found\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_INTEGRITY]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] %s%4lld ms%s - Invalid header\\n", CYAN, duration, RESET);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_INTEGRITY]++;\n    \n    // TEST 2: Record count matches header\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "INTEGRITY 2: Record count verification");\n    fflush(stdout);\n    \n    start = get_current_time_ms();\n    \n    char count_cmd[512];\n    snprintf(count_cmd, sizeof(count_cmd),\n             "dd if=%s bs=1 skip=8 count=8 2>/dev/null | hexdump -e '1/8 \\"%%u\\"' 2>/dev/null", data_path);\n    \n    char header_count[64] = "0";\n    FILE *fp = popen(count_cmd, "r");\n    if (fp) {\n        if (fgets(header_count, sizeof(header_count), fp)) {\n            header_count[strcspn(header_count, "\\n")] = '\\0';\n        }\n        pclose(fp);\n    }\n    \n    int actual_count = count_instances_in_collection(db_name, "data");\n    duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    int header_count_val = atoi(header_count);\n    \n    if (header_count_val == actual_count && actual_count > 0) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Header count (%d) matches actual (%d)\\n", \n               CYAN, duration, RESET, header_count_val, actual_count);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_INTEGRITY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - Header count (%d) != actual (%d)\\n", \n               CYAN, duration, RESET, header_count_val, actual_count);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_INTEGRITY]++;\n    \n    printf(YELLOW "  Data integrity tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== EDGE CASE TESTS ====================\n\nint run_edge_case_tests_cli() {\n    printf("\\n" MAGENTA BOLD "EDGE CASE TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "edge_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    TestCase edge_tests[] = {\n        {\n            "Empty database name",\n            "%s create '' 2>&1 | grep -i 'error\\\\|invalid' > /dev/null",\n            "echo 'Handled'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 1\n        },\n        {\n            "Empty collection name",\n            "%s create testdb '' --schema --name-string 2>&1 | grep -i 'error\\\\|invalid' > /dev/null",\n            "echo 'Handled'", \n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 1\n        },\n        {\n            "Maximum length field name",\n            "%s create %s users --schema --aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-string > /dev/null 2>&1",\n            "echo 'Handled'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 0\n        },\n        {\n            "Empty query string",\n            "%s find %s users --where \\"\\" > /dev/null 2>&1",\n            "%s find %s users --where \\"\\" | grep -c '\\"_id\\"'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 0\n        },\n        {\n            "Very long query value",\n            "%s find %s users --where \\"name:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\" 2>&1 | grep -i 'error\\\\|invalid' > /dev/null",\n            "echo 'Handled'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 0\n        },\n        {\n            "Create collection with zero fields",\n            "%s create %s empty --schema 2>&1 | grep -i 'error\\\\|invalid' > /dev/null",\n            "test ! -d '/tmp/sydb_test/%s/empty'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_EDGE, 1\n        }\n    };\n    \n    int edge_count = sizeof(edge_tests) / sizeof(edge_tests[0]);\n    \n    for (int i = 0; i < edge_count; i++) {\n        total++;\n        \n        char final_command[1024];\n        char final_verification[1024];\n        \n        snprintf(final_command, sizeof(final_command), edge_tests[i].command, cli_command, db_name);\n        snprintf(final_verification, sizeof(final_verification), edge_tests[i].verification_command, cli_command, db_name);\n        \n        strcpy(edge_tests[i].command, final_command);\n        strcpy(edge_tests[i].verification_command, final_verification);\n        \n        if (execute_test_with_verification(&edge_tests[i])) {\n            passed++;\n        }\n    }\n    \n    printf(YELLOW "  Edge case tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== RECOVERY TESTS ====================\n\nint run_recovery_tests_cli() {\n    printf("\\n" MAGENTA BOLD "RECOVERY & ERROR HANDLING TESTS (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    if (test_level < 2) {\n        printf(YELLOW "  Skipping recovery tests (use --level=2 for comprehensive testing)\\n" RESET);\n        return 0;\n    }\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "recovery_test_%ld", time(NULL));\n    \n    // Setup\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    char insert_cmd[512];\n    \n    // Insert some initial data\n    for (int i = 0; i < 5; i++) {\n        snprintf(insert_cmd, sizeof(insert_cmd),\n                "%s create %s users --insert-one --name-\\"Initial%d\\" --age-%d > /dev/null 2>&1",\n                cli_command, db_name, i, 20 + i);\n        system(insert_cmd);\n    }\n    \n    // TEST 1: Lock file cleanup\n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "RECOVERY 1: Lock file cleanup after crash");\n    fflush(stdout);\n    \n    char lock_path[512];\n    snprintf(lock_path, sizeof(lock_path), "/tmp/sydb_test/%s/users/.data.lock", db_name);\n    \n    // Create a stale lock file\n    FILE* lock = fopen(lock_path, "w");\n    if (lock) {\n        fprintf(lock, "stale lock\\n");\n        fclose(lock);\n    }\n    \n    long long start = get_current_time_ms();\n    \n    // Try to write - should handle stale lock\n    snprintf(insert_cmd, sizeof(insert_cmd),\n            "%s create %s users --insert-one --name-\\"Lock Test\\" --age-99 > /dev/null 2>&1",\n            cli_command, db_name);\n    int write_result = system(insert_cmd);\n    \n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    // Check if lock file is gone\n    int lock_exists = file_exists(lock_path);\n    \n    if (write_result == 0 && !lock_exists) {\n        printf("[" GREEN "PASS" RESET "] %s%4lld ms%s - Stale lock handled\\n", CYAN, duration, RESET);\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_RECOVERY]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] %s%4lld ms%s - Lock handling needs improvement\\n", CYAN, duration, RESET);\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_RECOVERY]++;\n    \n    printf(YELLOW "  Recovery tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== LEVEL 3 ENHANCED HTTP TESTS ====================\n\n// New test: Stress test - 1000 concurrent requests with mixed operations\nint run_http_stress_tests(void) {\n    printf("\\n" MAGENTA BOLD "EXTREME STRESS TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "stress_test_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "STRESS TEST 1: 1000 concurrent inserts");\n    fflush(stdout);\n    \n    long long start = get_current_time_ms();\n    \n    #define STRESS_THREAD_COUNT 10\n    #define STRESS_OPS_PER_THREAD 100\n    pthread_t stress_threads[STRESS_THREAD_COUNT];\n    ThreadTestContext stress_contexts[STRESS_THREAD_COUNT];\n    \n    for (int i = 0; i < STRESS_THREAD_COUNT; i++) {\n        memset(&stress_contexts[i], 0, sizeof(ThreadTestContext));\n        strcpy(stress_contexts[i].database, db_name);\n        strcpy(stress_contexts[i].collection, "users");\n        stress_contexts[i].thread_id = i;\n        stress_contexts[i].operations_count = STRESS_OPS_PER_THREAD;\n    }\n    \n    for (int i = 0; i < STRESS_THREAD_COUNT; i++) {\n        pthread_create(&stress_threads[i], NULL, http_concurrent_thread, &stress_contexts[i]);\n    }\n    \n    for (int i = 0; i < STRESS_THREAD_COUNT; i++) {\n        pthread_join(stress_threads[i], NULL);\n    }\n    \n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    int total_success = 0;\n    for (int i = 0; i < STRESS_THREAD_COUNT; i++) {\n        total_success += stress_contexts[i].success_count;\n    }\n    \n    // Verify count via GET\n    HttpResponse* verify_resp = http_request("GET", instances_url, NULL, NULL);\n    int record_count = 0;\n    if (verify_resp && verify_resp->body) {\n        char* pos = verify_resp->body;\n        while ((pos = strstr(pos, "\\"_id\\"")) != NULL) {\n            record_count++;\n            pos += 5;\n        }\n    }\n    http_response_free(verify_resp);\n    \n    printf(" - %lld ms, %d/%d records\\n", duration, record_count, total_success);\n    \n    if (record_count == total_success && total_success >= (STRESS_THREAD_COUNT * STRESS_OPS_PER_THREAD * 0.95)) {\n        printf("  [" GREEN "PASS" RESET "] Stress test passed\\n");\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_PERFORMANCE]++;\n    } else {\n        printf("  [" RED "FAIL" RESET "] Stress test failed: expected ~%d, got %d\\n", \n               STRESS_THREAD_COUNT * STRESS_OPS_PER_THREAD, record_count);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    return passed;\n}\n\n// New test: Data corruption detection\nint run_http_data_corruption_tests(void) {\n    printf("\\n" MAGENTA BOLD "DATA CORRUPTION TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    // This test requires direct file manipulation to simulate corruption\n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "corrupt_test_%ld", time(NULL));\n    \n    // Setup via CLI for file access\n    char setup_cmd[512];\n    snprintf(setup_cmd, sizeof(setup_cmd), "%s create %s > /dev/null 2>&1", cli_command, db_name);\n    system(setup_cmd);\n    snprintf(setup_cmd, sizeof(setup_cmd), \n             "%s create %s users --schema --name-string-req --age-int > /dev/null 2>&1", \n             cli_command, db_name);\n    system(setup_cmd);\n    \n    // Insert some data\n    for (int i = 0; i < 5; i++) {\n        char insert_cmd[512];\n        snprintf(insert_cmd, sizeof(insert_cmd),\n                "%s create %s users --insert-one --name-\\"User%d\\" --age-%d > /dev/null 2>&1",\n                cli_command, db_name, i, 20 + i);\n        system(insert_cmd);\n    }\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "CORRUPTION 1: Corrupt data file header");\n    fflush(stdout);\n    \n    char data_path[512];\n    snprintf(data_path, sizeof(data_path), "/tmp/sydb_test/%s/users/data.sydb", db_name);\n    \n    // Corrupt the magic number\n    FILE* data_file = fopen(data_path, "r+b");\n    if (data_file) {\n        uint32_t corrupt_magic = 0xDEADBEEF;\n        fwrite(&corrupt_magic, 4, 1, data_file);\n        fclose(data_file);\n    }\n    \n    // Try to read via HTTP - should handle corruption gracefully\n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    HttpResponse* resp = http_request("GET", instances_url, NULL, NULL);\n    \n    int success = (resp && (resp->status_code == 500 || resp->status_code == 400));\n    if (resp) http_response_free(resp);\n    \n    if (success) {\n        printf("[" GREEN "PASS" RESET "] Server correctly rejected corrupt file\\n");\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_INTEGRITY]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] Server did not detect corruption\\n");\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_INTEGRITY]++;\n    \n    return passed;\n}\n\n// New test: Mixed workload with read/write/delete operations\nint run_http_mixed_workload_tests(void) {\n    printf("\\n" MAGENTA BOLD "MIXED WORKLOAD TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "mixed_test_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/users/instances", db_name);\n    \n    // Insert 50 records\n    for (int i = 0; i < 50; i++) {\n        char user_json[256];\n        snprintf(user_json, sizeof(user_json), "{\\"name\\":\\"User%d\\",\\"age\\":%d}", i, 20 + i);\n        HttpResponse* r = http_request("POST", instances_url, user_json, "application/json");\n        http_response_free(r);\n    }\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "MIXED 1: Concurrent read/write/delete operations");\n    fflush(stdout);\n    \n    // This test requires multiple threads doing different operations\n    // Simplified for this example\n    printf(" - SKIPPED (requires advanced thread coordination)\\n");\n    stats.skipped_tests++;\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_CONCURRENCY]++;\n    \n    return passed;\n}\n\n// New test: Long-running connection stability\nint run_http_long_running_tests(void) {\n    printf("\\n" MAGENTA BOLD "LONG-RUNNING TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "LONG 1: Keep-alive connection stability (30s)");\n    fflush(stdout);\n    \n    printf(" - " YELLOW "SIMULATED" RESET " (would run for 30 seconds in actual test)\\n");\n    stats.skipped_tests++;\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    return passed;\n}\n\n// New test: Consistency under concurrent operations\nint run_http_consistency_tests(void) {\n    printf("\\n" MAGENTA BOLD "CONSISTENCY TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "consistency_test_%ld", time(NULL));\n    \n    // Setup\n    char create_db_body[256];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", db_name);\n    HttpResponse* resp = http_request("POST", "/api/databases", create_db_body, "application/json");\n    http_response_free(resp);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", db_name);\n    const char* schema = "{\\"name\\":\\"counter\\",\\"schema\\":["\n        "{\\"name\\":\\"value\\",\\"type\\":\\"int\\"}]}";\n    resp = http_request("POST", create_coll_url, schema, "application/json");\n    http_response_free(resp);\n    \n    char instances_url[256];\n    snprintf(instances_url, sizeof(instances_url), "/api/databases/%s/collections/counter/instances", db_name);\n    \n    // Insert initial counter\n    const char* counter_json = "{\\"value\\":0}";\n    resp = http_request("POST", instances_url, counter_json, "application/json");\n    char* id = NULL;\n    if (resp && resp->body) {\n        id = extract_json_field(resp->body, "id");\n    }\n    http_response_free(resp);\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "CONSISTENCY 1: Counter increment under load");\n    fflush(stdout);\n    \n    if (!id) {\n        printf("[" RED "FAIL" RESET "] Failed to create counter\\n");\n        stats.failed_tests++;\n        stats.critical_failures++;\n        stats.total_tests++;\n        stats.categories_total[CATEGORY_INTEGRITY]++;\n        return 0;\n    }\n    \n    char update_url[512];\n    snprintf(update_url, sizeof(update_url), "/api/databases/%s/collections/counter/instances/%s", db_name, id);\n    \n    // Perform 100 concurrent increments\n    #define INCREMENT_THREADS 10\n    #define INCREMENTS_PER_THREAD 10\n    \n    pthread_t inc_threads[INCREMENT_THREADS];\n    ThreadTestContext inc_contexts[INCREMENT_THREADS];\n    \n    for (int i = 0; i < INCREMENT_THREADS; i++) {\n        memset(&inc_contexts[i], 0, sizeof(ThreadTestContext));\n        strcpy(inc_contexts[i].database, db_name);\n        strcpy(inc_contexts[i].collection, "counter");\n        inc_contexts[i].thread_id = i;\n        inc_contexts[i].operations_count = INCREMENTS_PER_THREAD;\n    }\n    \n    long long start = get_current_time_ms();\n    \n    for (int i = 0; i < INCREMENT_THREADS; i++) {\n        pthread_create(&inc_threads[i], NULL, http_concurrent_thread, &inc_contexts[i]);\n    }\n    \n    for (int i = 0; i < INCREMENT_THREADS; i++) {\n        pthread_join(inc_threads[i], NULL);\n    }\n    \n    long long duration = get_current_time_ms() - start;\n    stats.total_duration += duration;\n    \n    // Check final value\n    char get_url[512];\n    snprintf(get_url, sizeof(get_url), "/api/databases/%s/collections/counter/instances/%s", db_name, id);\n    HttpResponse* get_resp = http_request("GET", get_url, NULL, NULL);\n    \n    int final_value = 0;\n    if (get_resp && get_resp->body) {\n        char* value_str = extract_json_field(get_resp->body, "value");\n        if (value_str) {\n            final_value = atoi(value_str);\n            free(value_str);\n        }\n    }\n    http_response_free(get_resp);\n    free(id);\n    \n    printf(" - %lld ms, final value: %d\\n", duration, final_value);\n    \n    if (final_value == INCREMENT_THREADS * INCREMENTS_PER_THREAD) {\n        printf("  [" GREEN "PASS" RESET "] Counter consistency maintained\\n");\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_INTEGRITY]++;\n    } else {\n        printf("  [" RED "FAIL" RESET "] Counter inconsistent: expected %d, got %d\\n", \n               INCREMENT_THREADS * INCREMENTS_PER_THREAD, final_value);\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_INTEGRITY]++;\n    \n    return passed;\n}\n\n// New test: Fault injection\nint run_http_fault_injection_tests(void) {\n    printf("\\n" MAGENTA BOLD "FAULT INJECTION TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "FAULT 1: Malformed JSON with control characters");\n    fflush(stdout);\n    \n    const char* malformed_json = "{\\"name\\":\\"Test\\x00User\\",\\"age\\":30}";\n    HttpResponse* resp = http_request("POST", "/api/databases/testdb/collections/users/instances", \n                                      malformed_json, "application/json");\n    \n    int success = (resp && (resp->status_code == 400 || resp->status_code == 500));\n    if (resp) http_response_free(resp);\n    \n    if (success) {\n        printf("[" GREEN "PASS" RESET "] Server rejected malformed JSON\\n");\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SECURITY]++;\n    } else {\n        printf("[" RED "FAIL" RESET "] Server accepted malformed JSON\\n");\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_SECURITY]++;\n    \n    return passed;\n}\n\n// New test: Chaos engineering - random failures\nint run_http_chaos_tests(void) {\n    printf("\\n" MAGENTA BOLD "CHAOS ENGINEERING TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    printf(YELLOW "Simulating random failures and partial outages\\n" RESET);\n    \n    int passed = 0;\n    int total = 0;\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "CHAOS 1: Simulate network latency");\n    fflush(stdout);\n    \n    printf(" - " YELLOW "SIMULATED" RESET "\\n");\n    stats.skipped_tests++;\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_RECOVERY]++;\n    \n    return passed;\n}\n\n// New test: Extreme boundary conditions\nint run_http_boundary_tests_extreme(void) {\n    printf("\\n" MAGENTA BOLD "EXTREME BOUNDARY TESTS (HTTP) - LEVEL 3 ONLY" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "BOUNDARY 1: Maximum field count (128 fields)");\n    fflush(stdout);\n    \n    char large_json[16384] = "{";\n    for (int i = 0; i < 128; i++) {\n        char field[128];\n        snprintf(field, sizeof(field), "\\"field%d\\":\\"value%d\\"", i, i);\n        if (i > 0) strcat(large_json, ",");\n        strcat(large_json, field);\n    }\n    strcat(large_json, "}");\n    \n    HttpResponse* resp = http_request("POST", "/api/databases/testdb/collections/users/instances", \n                                      large_json, "application/json");\n    \n    int success = (resp && resp->status_code >= 200 && resp->status_code < 300);\n    if (resp) http_response_free(resp);\n    \n    if (success) {\n        printf("[" GREEN "PASS" RESET "] Server handled 128 fields\\n");\n        passed++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_PERFORMANCE]++;\n    } else {\n        printf("[" YELLOW "WARN" RESET "] Server failed with 128 fields\\n");\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    total++;\n    printf("\\n%s%-80s" RESET, BLUE, "BOUNDARY 2: Very large JSON (1MB)");\n    fflush(stdout);\n    \n    char* huge_json = malloc(1024 * 1024 + 100);\n    if (huge_json) {\n        strcpy(huge_json, "{\\"data\\":\\"");\n        for (int i = 0; i < 1024 * 1024 - 100; i++) {\n            huge_json[10 + i] = 'A' + (i % 26);\n        }\n        strcpy(huge_json + 10 + 1024 * 1024 - 100, "\\"}");\n        \n        resp = http_request("POST", "/api/databases/testdb/collections/users/instances", \n                            huge_json, "application/json");\n        \n        success = (resp && resp->status_code >= 200 && resp->status_code < 300);\n        if (resp) http_response_free(resp);\n        free(huge_json);\n        \n        if (success) {\n            printf("[" GREEN "PASS" RESET "] Server handled 1MB JSON\\n");\n            passed++;\n            stats.passed_tests++;\n            stats.categories_passed[CATEGORY_PERFORMANCE]++;\n        } else {\n            printf("[" YELLOW "WARN" RESET "] Server rejected 1MB JSON\\n");\n            stats.skipped_tests++;\n        }\n    } else {\n        printf("[" YELLOW "SKIP" RESET "] Memory allocation failed\\n");\n        stats.skipped_tests++;\n    }\n    stats.total_tests++;\n    stats.categories_total[CATEGORY_PERFORMANCE]++;\n    \n    return passed;\n}\n\n// ==================== SMOKE TESTS (Your original CLI tests) ====================\n\nint run_smoke_tests_cli() {\n    printf("\\n" MAGENTA BOLD "SMOKE TESTS - Basic Functionality (CLI)" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    \n    // Clean up\n    system("rm -rf /tmp/sydb_test > /dev/null 2>&1");\n    \n    TestCase tests[] = {\n        {\n            "Create database 'testdb'", \n            "%s create testdb > /dev/null 2>&1",\n            "test -d '/tmp/sydb_test/testdb'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Create database 'testdb2'", \n            "%s create testdb2 > /dev/null 2>&1",\n            "test -d '/tmp/sydb_test/testdb2'", \n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "List databases",\n            "%s list > /dev/null 2>&1", \n            "%s list | grep -c 'testdb\\\\|testdb2'",\n            "2",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Create 'users' collection with schema",\n            "%s create testdb users --schema --name-string-req --age-int --email-string > /dev/null 2>&1",\n            "test -f '/tmp/sydb_test/testdb/users/schema.txt'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Create 'products' collection",\n            "%s create testdb products --schema --name-string-req --price-float > /dev/null 2>&1",\n            "test -f '/tmp/sydb_test/testdb/products/schema.txt'",\n            "",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Insert user record",\n            "%s create testdb users --insert-one --name-\\"John Doe\\" --age-30 --email-\\"john@test.com\\" > /dev/null 2>&1",\n            "%s list testdb users | grep -c '\\"_id\\"'",\n            "1",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Insert second user", \n            "%s create testdb users --insert-one --name-\\"Jane Smith\\" --age-25 --email-\\"jane@test.com\\" > /dev/null 2>&1",\n            "%s list testdb users | grep -c '\\"_id\\"'",\n            "2",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Insert product",\n            "%s create testdb products --insert-one --name-\\"Test Product\\" --price-19.99 > /dev/null 2>&1",\n            "%s list testdb products | grep -c 'Test Product'",\n            "1",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Query by age",\n            "%s find testdb users --where \\"age:30\\" > /dev/null 2>&1",\n            "%s find testdb users --where \\"age:30\\" | grep -c 'John Doe'",\n            "1", \n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Query non-existent",\n            "%s find testdb users --where \\"age:999\\" > /dev/null 2>&1",\n            "%s find testdb users --where \\"age:999\\" | wc -l",\n            "0",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "List collections",\n            "%s list testdb > /dev/null 2>&1",\n            "%s list testdb | grep -c 'users\\\\|products'", \n            "2",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "List users",\n            "%s list testdb users > /dev/null 2>&1",\n            "%s list testdb users | grep -c '\\"_id\\"'",\n            "2",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        },\n        {\n            "Verify UUID format",\n            "%s list testdb users | head -1 > /dev/null 2>&1",\n            "%s list testdb users | head -1 | grep -Eo '\\"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\\"' | wc -l",\n            "1",\n            0, 0, 0, "", "",\n            CATEGORY_SMOKE, 1\n        }\n    };\n    \n    int test_count = sizeof(tests) / sizeof(tests[0]);\n    \n    for (int i = 0; i < test_count; i++) {\n        total++;\n        \n        char final_command[1024];\n        char final_verification[1024];\n        \n        snprintf(final_command, sizeof(final_command), tests[i].command, cli_command);\n        snprintf(final_verification, sizeof(final_verification), tests[i].verification_command, cli_command);\n        \n        strcpy(tests[i].command, final_command);\n        strcpy(tests[i].verification_command, final_verification);\n        \n        if (execute_test_with_verification(&tests[i])) {\n            passed++;\n        }\n    }\n    \n    printf(YELLOW "  Smoke tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\nint run_smoke_tests_http() {\n    printf("\\n" MAGENTA BOLD "SMOKE TESTS - Basic HTTP API" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long duration;\n    \n    // Test connectivity\n    HttpResponse* test_response = http_request("GET", "/api/databases", NULL, NULL);\n    if (test_response && test_response->status_code > 0) {\n        printf("\\n%s%-80s" RESET, BLUE, "Server connectivity test");\n        printf("[" GREEN "PASS" RESET "]\\n");\n        passed++;\n        total++;\n        stats.passed_tests++;\n        stats.categories_passed[CATEGORY_SMOKE]++;\n    } else {\n        printf("\\n%s%-80s" RESET, BLUE, "Server connectivity test");\n        printf("[" RED "FAIL" RESET "]\\n");\n        total++;\n        stats.failed_tests++;\n        stats.critical_failures++;\n    }\n    stats.total_tests += total;\n    stats.categories_total[CATEGORY_SMOKE] += total;\n    http_response_free(test_response);\n    \n    // List databases\n    if (http_test_endpoint("GET /api/databases", \n                          "GET", "/api/databases", NULL, "\\"success\\":true", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    \n    // Create database\n    char db_name[64];\n    snprintf(db_name, sizeof(db_name), "smoke_test_%ld", time(NULL));\n    char create_body[256];\n    snprintf(create_body, sizeof(create_body), "{\\"name\\":\\"%s\\"}", db_name);\n    \n    if (http_test_endpoint("POST /api/databases - Create database", \n                          "POST", "/api/databases", create_body, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    \n    printf(YELLOW "  HTTP Smoke tests: %d/%d passed\\n" RESET, passed, total);\n    return passed;\n}\n\n// ==================== TEST SUITE DISPATCHER ====================\n\nvoid run_all_cli_tests() {\n    printf(CYAN BOLD "\\n===============================================\\n" RESET);\n    printf(CYAN BOLD "   SYDB CLI COMPREHENSIVE TEST SUITE\\n" RESET);\n    printf(CYAN BOLD "===============================================\\n" RESET);\n    printf("Command: %s\\n", cli_command);\n    printf("Test level: %s\\n", \n           test_level == 0 ? "Quick" : \n           test_level == 1 ? "Standard" : \n           test_level == 2 ? "Comprehensive" : "Extreme");\n    printf("Verbose: %s\\n", verbose_mode ? "Yes" : "No");\n    printf(CYAN BOLD "===============================================\\n\\n" RESET);\n    \n    // Cleanup\n    system("rm -rf /tmp/sydb_test > /dev/null 2>&1");\n    mkdir("/tmp/sydb_test", 0755);\n    \n    // Run test categories in order\n    run_smoke_tests_cli();\n    \n    if (test_level >= 1) {\n        run_security_tests_cli();\n        run_schema_enforcement_tests_cli();\n        run_query_language_tests_cli();\n        run_data_integrity_tests_cli(); // Actually run_integrity_tests_cli\n        run_edge_case_tests_cli();\n        run_performance_tests_cli();\n        run_concurrency_tests_cli();\n    }\n    \n    if (test_level >= 2) {\n        run_durability_tests_cli();\n        run_recovery_tests_cli();\n    }\n    \n    // Extreme level tests for CLI (level 3)\n    if (test_level >= 3) {\n        // Add CLI extreme tests here if needed\n    }\n}\n\nvoid run_all_http_tests() {\n    printf(CYAN BOLD "\\n===============================================\\n" RESET);\n    printf(CYAN BOLD "   SYDB HTTP API COMPREHENSIVE TEST SUITE\\n" RESET);\n    printf(CYAN BOLD "===============================================\\n" RESET);\n    printf("Server URL: %s\\n", server_url);\n    printf("Test level: %s\\n", \n           test_level == 0 ? "Quick" : \n           test_level == 1 ? "Standard" : \n           test_level == 2 ? "Comprehensive" : "Extreme");\n    printf("Verbose: %s\\n", verbose_mode ? "Yes" : "No");\n    printf(CYAN BOLD "===============================================\\n\\n" RESET);\n    \n    // Test connectivity first\n    HttpResponse* test_response = http_request("GET", "/api/databases", NULL, NULL);\n    if (!test_response || test_response->status_code == 0) {\n        printf(RED "ERROR: Cannot connect to server at %s\\n" RESET, server_url);\n        printf(YELLOW "Attempting to start server automatically...\\n" RESET);\n        \n        if (!start_sydb_server()) {\n            printf(RED "Failed to start server. Please start manually with: %s --server\\n" RESET, cli_command);\n            http_response_free(test_response);\n            return;\n        }\n    }\n    http_response_free(test_response);\n    \n    // Clean up old test databases\n    cleanup_test_databases();\n    \n    // Level 0: Smoke tests only\n    run_smoke_tests_http();\n    \n    // Level 1: Standard tests\n    if (test_level >= 1) {\n        run_http_database_tests();\n        run_http_collection_tests();\n        run_http_instance_tests();\n        run_http_command_tests();\n        run_http_error_tests();\n        run_security_tests_http();\n        run_schema_enforcement_tests_http();\n        run_query_language_tests_http();\n        run_performance_tests_http();\n    }\n    \n    // Level 2: Comprehensive tests\n    if (test_level >= 2) {\n        run_concurrency_tests_http();\n        run_durability_tests_http();\n    }\n    \n    // Level 3: Extreme tests (NEW - much more robust than level 2)\n    if (test_level >= 3) {\n        printf("\\n" MAGENTA BOLD "===============================================\\n" RESET);\n        printf(MAGENTA BOLD "   EXTREME TEST SUITE - LEVEL 3\\n" RESET);\n        printf(MAGENTA BOLD "   These tests push the system to its limits\\n" RESET);\n        printf(MAGENTA BOLD "===============================================\\n" RESET);\n        \n        // Run all level 3 enhanced tests\n        run_http_stress_tests();\n        run_http_data_corruption_tests();\n        run_http_mixed_workload_tests();\n        run_http_long_running_tests();\n        run_http_consistency_tests();\n        run_http_fault_injection_tests();\n        run_http_chaos_tests();\n        run_http_boundary_tests_extreme();\n        \n        printf("\\n" MAGENTA BOLD "===============================================\\n" RESET);\n    }\n    \n    // Stop server if we started it\n    if (server_started_by_test) {\n        stop_sydb_server();\n    }\n}\n\n// ==================== CLEANUP FUNCTION ====================\n\nvoid cleanup_test_databases() {\n    printf("Cleaning up previous test databases...\\n");\n    \n    if (verbose_mode) {\n        printf(YELLOW "  [VERBOSE] Cleaning up test directories in /tmp/sydb_test/\\n" RESET);\n    }\n    \n    char command[512];\n    snprintf(command, sizeof(command), "rm -rf /tmp/sydb_test/testdb_* /tmp/sydb_test/testdb2_* /tmp/sydb_test/testcolldb_* /tmp/sydb_test/testinstdb_* 2>/dev/null");\n    system(command);\n    \n    snprintf(command, sizeof(command), "rm -f /tmp/sydb_test/*.lock /tmp/sydb_test/.*.lock 2>/dev/null");\n    system(command);\n    \n    usleep(50000);\n    \n    if (verbose_mode) {\n        printf(YELLOW "  [VERBOSE] Cleanup completed\\n" RESET);\n    }\n}\n\n// ==================== RESULTS REPORTING ====================\n\nvoid print_final_results() {\n    printf("\\n");\n    printf(CYAN BOLD "===============================================\\n" RESET);\n    printf(CYAN BOLD "           FINAL TEST RESULTS\\n" RESET);\n    printf(CYAN BOLD "===============================================\\n" RESET);\n    \n    printf("Total Tests:      %d\\n", stats.total_tests);\n    printf("Passed:           " GREEN "%d" RESET "\\n", stats.passed_tests);\n    printf("Failed:           " RED "%d" RESET "\\n", stats.failed_tests);\n    printf("Skipped:          " YELLOW "%d" RESET "\\n", stats.skipped_tests);\n    printf("Critical Failures:" RED "%d" RESET "\\n", stats.critical_failures);\n    printf("Total Duration:   " CYAN "%lld ms" RESET "\\n", stats.total_duration);\n    \n    printf("\\n" BOLD "Category Breakdown:\\n" RESET);\n    printf("------------------------------------------------\\n");\n    \n    const char* cat_names[] = {\n        "Smoke Tests",\n        "Durability", \n        "Concurrency",\n        "Query Language",\n        "Schema Enforcement",\n        "Security",\n        "Performance",\n        "Data Integrity",\n        "Edge Cases",\n        "Recovery"\n    };\n    \n    for (int i = 0; i < 10; i++) {\n        if (stats.categories_total[i] > 0) {\n            double pct = (double)stats.categories_passed[i] / stats.categories_total[i] * 100;\n            char* color = pct >= 90 ? GREEN : (pct >= 70 ? YELLOW : RED);\n            \n            printf("%-18s: %s%2d/%-2d (%3.0f%%)%s\\n", \n                   cat_names[i], color, \n                   stats.categories_passed[i], stats.categories_total[i], pct, RESET);\n        }\n    }\n    \n    printf(CYAN BOLD "===============================================\\n" RESET);\n    \n    // Overall verdict\n    printf("\\n" BOLD "VERDICT: " RESET);\n    \n    if (stats.critical_failures == 0 && stats.passed_tests >= stats.total_tests * 0.9) {\n        printf(GREEN "PASS - All critical tests passed\\n" RESET);\n    } else if (stats.critical_failures == 0 && stats.passed_tests >= stats.total_tests * 0.7) {\n        printf(YELLOW "PASS WITH WARNINGS - Some non-critical tests failed\\n" RESET);\n    } else {\n        printf(RED "FAIL - Critical failures detected\\n" RESET);\n        printf("\\n" YELLOW "SyDB is NOT ready for production use.\\n" RESET);\n        printf(YELLOW "The following critical areas need attention:\\n" RESET);\n        \n        if (stats.categories_passed[CATEGORY_DURABILITY] < stats.categories_total[CATEGORY_DURABILITY]) {\n            printf(RED "   Durability/Crash Recovery - Data may not survive power loss\\n" RESET);\n        }\n        if (stats.categories_passed[CATEGORY_CONCURRENCY] < stats.categories_total[CATEGORY_CONCURRENCY]) {\n            printf(RED "   Concurrency - May corrupt under parallel load\\n" RESET);\n        }\n        if (stats.categories_passed[CATEGORY_SCHEMA] < stats.categories_total[CATEGORY_SCHEMA]) {\n            printf(RED "   Schema Enforcement - Not properly validating data\\n" RESET);\n        }\n        if (stats.categories_passed[CATEGORY_RECOVERY] < stats.categories_total[CATEGORY_RECOVERY]) {\n            printf(RED "   Recovery - Cannot recover from crashes/corruption\\n" RESET);\n        }\n        if (stats.categories_passed[CATEGORY_INTEGRITY] < stats.categories_total[CATEGORY_INTEGRITY]) {\n            printf(RED "   Data Integrity - File format issues detected\\n" RESET);\n        }\n    }\n    \n    printf(CYAN BOLD "===============================================\\n\\n" RESET);\n}\n\n// ==================== MAIN FUNCTION ====================\n\nvoid print_usage(const char *program_name) {\n    printf("Usage: %s [OPTIONS]\\n", program_name);\n    printf("\\n");\n    printf("TEST MODES:\\n");\n    printf("  --cli           Test CLI mode (default if no mode specified)\\n");\n    printf("  --server        Test HTTP API mode (requires running server or will auto-start)\\n");\n    printf("\\n");\n    printf("TEST LEVELS:\\n");\n    printf("  --level=0       Quick mode - smoke tests only\\n");\n    printf("  --level=1       Standard mode - core functionality (default)\\n");\n    printf("  --level=2       Comprehensive - includes durability & concurrency\\n");\n    printf("  --level=3       Extreme - stress, corruption, chaos, and boundary tests\\n");\n    printf("\\n");\n    printf("OPTIONS:\\n");\n    printf("  --command=PATH  Specify sydb command path (default: ./sydb)\\n");\n    printf("  --url=URL       Specify server URL for HTTP tests (default: http://localhost:8080)\\n");\n    printf("  --verbose       Enable extremely detailed logging\\n");\n    printf("  --help, -h      Show this help message\\n");\n    printf("\\n");\n    printf("EXAMPLES:\\n");\n    printf("  %s                         # Quick CLI smoke tests\\n", program_name);\n    printf("  %s --level=1               # Standard CLI tests\\n", program_name);\n    printf("  %s --level=2 --verbose     # Comprehensive CLI tests with debug output\\n", program_name);\n    printf("  %s --level=3               # Extreme CLI tests (if available)\\n", program_name);\n    printf("  %s --server --level=1      # Standard HTTP API tests\\n", program_name);\n    printf("  %s --server --level=3      # Extreme HTTP API tests\\n", program_name);\n    printf("  %s --server --url=http://localhost:9000  # HTTP tests on custom port\\n", program_name);\n}\n\nint main(int argc, char *argv[]) {\n    // Default settings\n    test_mode = TEST_MODE_CLI;  // Default to CLI\n    test_level = 1;             // Default to standard\n    verbose_mode = 0;\n    strcpy(cli_command, "./sydb");\n    strcpy(server_url, "http://localhost:8080");\n    \n    // Parse command line arguments\n    for (int i = 1; i < argc; i++) {\n        if (strcmp(argv[i], "--cli") == 0) {\n            test_mode = TEST_MODE_CLI;\n        } else if (strcmp(argv[i], "--server") == 0) {\n            test_mode = TEST_MODE_SERVER;\n        } else if (strcmp(argv[i], "--verbose") == 0) {\n            verbose_mode = 1;\n        } else if (strncmp(argv[i], "--level=", 8) == 0) {\n            test_level = atoi(argv[i] + 8);\n            if (test_level < 0 || test_level > 3) test_level = 1;\n        } else if (strncmp(argv[i], "--command=", 10) == 0) {\n            strncpy(cli_command, argv[i] + 10, sizeof(cli_command) - 1);\n        } else if (strncmp(argv[i], "--url=", 6) == 0) {\n            strncpy(server_url, argv[i] + 6, sizeof(server_url) - 1);\n        } else if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {\n            print_usage(argv[0]);\n            return 0;\n        } else {\n            fprintf(stderr, RED "Unknown option: %s\\n" RESET, argv[i]);\n            print_usage(argv[0]);\n            return 1;\n        }\n    }\n    \n    // Set environment\n    setenv("SYDB_BASE_DIR", "/tmp/sydb_test", 1);\n    \n    // Initialize statistics\n    memset(&stats, 0, sizeof(stats));\n    \n    // Run tests based on mode\n    long long overall_start = get_current_time_ms();\n    \n    if (test_mode == TEST_MODE_CLI) {\n        run_all_cli_tests();\n    } else if (test_mode == TEST_MODE_SERVER) {\n        run_all_http_tests();\n    }\n    \n    stats.total_duration = get_current_time_ms() - overall_start;\n    \n    // Print results\n    print_final_results();\n    \n    // Return code based on critical failures\n    return (stats.critical_failures == 0 && stats.passed_tests >= stats.total_tests * 0.7) ? 0 : 1;\n}\n\n// ==================== ORIGINAL HTTP TEST FUNCTIONS ====================\n// Copy these exactly from your original test.c\n\nint run_http_database_tests() {\n    printf("\\n" MAGENTA "HTTP API DATABASE TESTS" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long total_time = 0;\n    long long duration;\n    \n    char unique_db1[64], unique_db2[64];\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    snprintf(unique_db1, sizeof(unique_db1), "testdb_%ld_%ld", ts.tv_sec, ts.tv_nsec);\n    snprintf(unique_db2, sizeof(unique_db2), "testdb2_%ld_%ld", ts.tv_sec, ts.tv_nsec + 1);\n    \n    char create_db1_body[128], create_db2_body[128];\n    snprintf(create_db1_body, sizeof(create_db1_body), "{\\"name\\":\\"%s\\"}", unique_db1);\n    snprintf(create_db2_body, sizeof(create_db2_body), "{\\"name\\":\\"%s\\"}", unique_db2);\n    \n    if (http_test_endpoint("GET /api/databases - List databases", \n                          "GET", "/api/databases", NULL, "\\"success\\":true", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("POST /api/databases - Create database", \n                          "POST", "/api/databases", create_db1_body, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("POST /api/databases - Create second database", \n                          "POST", "/api/databases", create_db2_body, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("POST /api/databases - Prevent duplicate database", \n                          "POST", "/api/databases", create_db1_body, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char delete_url[256];\n    snprintf(delete_url, sizeof(delete_url), "/api/databases/%s", unique_db2);\n    if (http_test_endpoint("DELETE /api/databases/{name} - Delete database", \n                          "DELETE", delete_url, NULL, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    printf(YELLOW "  Database API tests: %d/%d passed (avg: %lld ms)\\n" RESET, \n           passed, total, total_time / (total > 0 ? total : 1));\n    \n    return passed;\n}\n\nint run_http_collection_tests() {\n    printf("\\n" MAGENTA "HTTP API COLLECTION TESTS" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long total_time = 0;\n    long long duration;\n    \n    char unique_db[64];\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    snprintf(unique_db, sizeof(unique_db), "testcolldb_%ld_%ld", ts.tv_sec, ts.tv_nsec);\n    \n    char create_db_body[128];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", unique_db);\n    \n    HttpResponse* db_response = http_request("POST", "/api/databases", create_db_body, "application/json");\n    if (!db_response || !verify_http_response(db_response, "\\"success\\":true", 0)) {\n        printf(RED "  Failed to create test database for collection tests\\n" RESET);\n        http_response_free(db_response);\n        return 0;\n    }\n    http_response_free(db_response);\n    \n    char list_colls_url[256];\n    snprintf(list_colls_url, sizeof(list_colls_url), "/api/databases/%s/collections", unique_db);\n    if (http_test_endpoint("GET /api/databases/{db}/collections - List empty collections", \n                          "GET", list_colls_url, NULL, "\\"collections\\":[]", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", unique_db);\n    \n    const char* users_schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true,\\"indexed\\":false},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\",\\"required\\":false,\\"indexed\\":false},"\n        "{\\"name\\":\\"email\\",\\"type\\":\\"string\\",\\"required\\":false,\\"indexed\\":false}"\n        "]}";\n    \n    if (http_test_endpoint("POST /api/databases/{db}/collections - Create users collection", \n                          "POST", create_coll_url, users_schema, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    const char* products_schema = "{\\"name\\":\\"products\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true,\\"indexed\\":false},"\n        "{\\"name\\":\\"price\\",\\"type\\":\\"float\\",\\"required\\":false,\\"indexed\\":false}"\n        "]}";\n    \n    if (http_test_endpoint("POST /api/databases/{db}/collections - Create products collection", \n                          "POST", create_coll_url, products_schema, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("GET /api/databases/{db}/collections - List created collections", \n                          "GET", list_colls_url, NULL, "\\"users\\"", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char schema_url[256];\n    snprintf(schema_url, sizeof(schema_url), "/api/databases/%s/collections/users/schema", unique_db);\n    if (http_test_endpoint("GET /api/databases/{db}/collections/{coll}/schema - Get users schema", \n                          "GET", schema_url, NULL, "\\"name\\"", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char delete_coll_url[256];\n    snprintf(delete_coll_url, sizeof(delete_coll_url), "/api/databases/%s/collections/products", unique_db);\n    if (http_test_endpoint("DELETE /api/databases/{db}/collections/{coll} - Delete products collection", \n                          "DELETE", delete_coll_url, NULL, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    printf(YELLOW "  Collection API tests: %d/%d passed (avg: %lld ms)\\n" RESET, \n           passed, total, total_time / (total > 0 ? total : 1));\n    \n    return passed;\n}\n\nint run_http_instance_tests() {\n    printf("\\n" MAGENTA "HTTP API INSTANCE TESTS" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long total_time = 0;\n    long long duration;\n    \n    char unique_db[64];\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    snprintf(unique_db, sizeof(unique_db), "testinstdb_%ld_%ld", ts.tv_sec, ts.tv_nsec);\n    \n    char create_db_body[128];\n    snprintf(create_db_body, sizeof(create_db_body), "{\\"name\\":\\"%s\\"}", unique_db);\n    \n    HttpResponse* db_response = http_request("POST", "/api/databases", create_db_body, "application/json");\n    if (!db_response || !verify_http_response(db_response, "\\"success\\":true", 0)) {\n        printf(RED "  Failed to create test database for instance tests\\n" RESET);\n        http_response_free(db_response);\n        return 0;\n    }\n    http_response_free(db_response);\n    \n    char create_coll_url[256];\n    snprintf(create_coll_url, sizeof(create_coll_url), "/api/databases/%s/collections", unique_db);\n    \n    const char* users_schema = "{\\"name\\":\\"users\\",\\"schema\\":["\n        "{\\"name\\":\\"name\\",\\"type\\":\\"string\\",\\"required\\":true,\\"indexed\\":false},"\n        "{\\"name\\":\\"age\\",\\"type\\":\\"int\\",\\"required\\":false,\\"indexed\\":false},"\n        "{\\"name\\":\\"email\\",\\"type\\":\\"string\\",\\"required\\":false,\\"indexed\\":false}"\n        "]}";\n    \n    HttpResponse* coll_response = http_request("POST", create_coll_url, users_schema, "application/json");\n    if (!coll_response || !verify_http_response(coll_response, "\\"success\\":true", 0)) {\n        printf(RED "  Failed to create test collection for instance tests\\n" RESET);\n        http_response_free(coll_response);\n        return 0;\n    }\n    http_response_free(coll_response);\n    \n    char list_instances_url[256];\n    snprintf(list_instances_url, sizeof(list_instances_url), "/api/databases/%s/collections/users/instances", unique_db);\n    if (http_test_endpoint("GET /api/databases/{db}/collections/{coll}/instances - List empty instances", \n                          "GET", list_instances_url, NULL, "\\"instances\\":[]", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    const char* user1 = "{\\"name\\":\\"John Doe\\",\\"age\\":30,\\"email\\":\\"john@test.com\\"}";\n    char insert_url[256];\n    snprintf(insert_url, sizeof(insert_url), "/api/databases/%s/collections/users/instances", unique_db);\n    \n    if (http_test_endpoint("POST /api/databases/{db}/collections/{coll}/instances - Insert first user", \n                          "POST", insert_url, user1, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    const char* user2 = "{\\"name\\":\\"Jane Smith\\",\\"age\\":25,\\"email\\":\\"jane@test.com\\"}";\n    if (http_test_endpoint("POST /api/databases/{db}/collections/{coll}/instances - Insert second user", \n                          "POST", insert_url, user2, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("GET /api/databases/{db}/collections/{coll}/instances - List users", \n                          "GET", list_instances_url, NULL, "John Doe", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char query_url[512];\n    snprintf(query_url, sizeof(query_url), "/api/databases/%s/collections/users/instances?query=age:30", unique_db);\n    if (http_test_endpoint("GET /api/.../instances?query=age:30 - Query by age", \n                          "GET", query_url, NULL, "John Doe", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    char* id = get_last_inserted_id(unique_db, "users");\n    if (id) {\n        char update_url[256];\n        snprintf(update_url, sizeof(update_url), "/api/databases/%s/collections/users/instances/%s", unique_db, id);\n        const char* update_data = "{\\"age\\":35,\\"email\\":\\"john.updated@test.com\\"}";\n        if (http_test_endpoint("PUT /api/.../instances/{id} - Update user", \n                              "PUT", update_url, update_data, "\\"success\\":true", 0, &duration,\n                              CATEGORY_SMOKE, 1)) {\n            passed++;\n        }\n        total++;\n        total_time += duration;\n        \n        char delete_url[256];\n        snprintf(delete_url, sizeof(delete_url), "/api/databases/%s/collections/users/instances/%s", unique_db, id);\n        if (http_test_endpoint("DELETE /api/.../instances/{id} - Delete user", \n                              "DELETE", delete_url, NULL, "\\"success\\":true", 0, &duration,\n                              CATEGORY_SMOKE, 1)) {\n            passed++;\n        }\n        total++;\n        total_time += duration;\n    }\n    \n    printf(YELLOW "  Instance API tests: %d/%d passed (avg: %lld ms)\\n" RESET, \n           passed, total, total_time / (total > 0 ? total : 1));\n    \n    return passed;\n}\n\nint run_http_command_tests() {\n    printf("\\n" MAGENTA "HTTP API COMMAND TESTS" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long total_time = 0;\n    long long duration;\n    \n    const char* command = "{\\"command\\":\\"list\\",\\"arguments\\":[]}";\n    if (http_test_endpoint("POST /api/execute - Execute list command", \n                          "POST", "/api/execute", command, "\\"success\\":true", 0, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    printf(YELLOW "  Command API tests: %d/%d passed (avg: %lld ms)\\n" RESET, \n           passed, total, total_time / total);\n    \n    return passed;\n}\n\nint run_http_error_tests() {\n    printf("\\n" MAGENTA "HTTP API ERROR HANDLING TESTS" RESET "\\n");\n    \n    int passed = 0;\n    int total = 0;\n    long long total_time = 0;\n    long long duration;\n    \n    if (http_test_endpoint("POST /api/databases - Invalid database name", \n                          "POST", "/api/databases", "{\\"name\\":\\"invalid/name\\"}", "\\"success\\":false", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("GET /api/databases/nonexistent/collections - Non-existent database", \n                          "GET", "/api/databases/nonexistent/collections", NULL, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("GET /api/databases/testdb/collections/nonexistent/instances - Non-existent collection", \n                          "GET", "/api/databases/testdb/collections/nonexistent/instances", NULL, "\\"success\\":false", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    if (http_test_endpoint("POST /api/databases - Invalid JSON", \n                          "POST", "/api/databases", "invalid json", "\\"success\\":false", 1, &duration,\n                          CATEGORY_SMOKE, 1)) {\n        passed++;\n    }\n    total++;\n    total_time += duration;\n    \n    printf(YELLOW "  Error handling tests: %d/%d passed (avg: %lld ms)\\n" RESET, \n           passed, total, total_time / (total > 0 ? total : 1));\n    \n    return passed;\n}\n`;

export default newtest;
